# Pek.Common 配置系统迁移指南

## 1. 简介

本文档提供了从其他配置系统迁移到 Pek.Common 配置系统的指南和最佳实践。迁移过程需要考虑配置数据的转换、应用程序代码的调整以及确保功能的一致性。本指南将帮助您平稳地完成迁移过程，最大限度地减少对应用程序的影响。

### 1.1 迁移目标

迁移到 Pek.Common 配置系统的目标包括：

- 保持配置数据的完整性和一致性
- 最小化对现有代码的修改
- 确保功能的连续性
- 利用 Pek.Common 配置系统的优势
- 提高配置管理的可维护性和灵活性

### 1.2 迁移前的准备

在开始迁移之前，请确保：

1. 了解当前配置系统的结构和功能
2. 了解 Pek.Common 配置系统的特性和优势
3. 识别配置数据的关键部分和依赖关系
4. 制定迁移计划和回滚策略
5. 准备测试环境和测试用例

## 2. 从常见配置系统迁移

### 2.1 从 appsettings.json 迁移

#### 2.1.1 迁移步骤

1. **分析现有配置**：分析 appsettings.json 文件的结构和内容

   ```json
   // 原始 appsettings.json
   {
     "Logging": {
       "LogLevel": {
         "Default": "Information",
         "Microsoft": "Warning",
         "Microsoft.Hosting.Lifetime": "Information"
       }
     },
     "ConnectionStrings": {
       "DefaultConnection": "Server=localhost;Database=myDb;User=sa;Password=yourPassword;"
     },
     "AppSettings": {
       "SiteTitle": "My Application",
       "EnableCache": true,
       "CacheTimeout": 3600
     }
   }
   ```

2. **创建配置类**：为每个配置部分创建强类型配置类

   ```csharp
   public class LoggingSettings
   {
       public Dictionary<string, string> LogLevel { get; set; } = new Dictionary<string, string>();
   }
   
   public class ConnectionStrings
   {
       public string DefaultConnection { get; set; } = "";
   }
   
   public class AppSettings
   {
       public string SiteTitle { get; set; } = "My Application";
       public bool EnableCache { get; set; } = true;
       public int CacheTimeout { get; set; } = 3600;
   }
   ```

3. **迁移配置数据**：将 appsettings.json 中的数据转换为 Pek.Common 配置格式

   ```csharp
   public class ConfigMigrator
   {
       public static void MigrateFromAppSettings(string appSettingsPath)
       {
           // 读取 appsettings.json
           string json = File.ReadAllText(appSettingsPath);
           JsonDocument doc = JsonDocument.Parse(json);
           
           // 迁移日志配置
           if (doc.RootElement.TryGetProperty("Logging", out JsonElement loggingElement))
           {
               var loggingSettings = new LoggingSettings();
               
               if (loggingElement.TryGetProperty("LogLevel", out JsonElement logLevelElement))
               {
                   foreach (JsonProperty property in logLevelElement.EnumerateObject())
                   {
                       loggingSettings.LogLevel[property.Name] = property.Value.GetString();
                   }
               }
               
               // 保存日志配置
               var loggingConfig = new Config<LoggingSettings>();
               loggingConfig.Current = loggingSettings;
               loggingConfig.Save();
           }
           
           // 迁移连接字符串
           if (doc.RootElement.TryGetProperty("ConnectionStrings", out JsonElement connectionStringsElement))
           {
               var connectionStrings = new ConnectionStrings();
               
               if (connectionStringsElement.TryGetProperty("DefaultConnection", out JsonElement defaultConnectionElement))
               {
                   connectionStrings.DefaultConnection = defaultConnectionElement.GetString();
               }
               
               // 保存连接字符串配置
               var connectionStringsConfig = new Config<ConnectionStrings>();
               connectionStringsConfig.Current = connectionStrings;
               connectionStringsConfig.Save();
           }
           
           // 迁移应用设置
           if (doc.RootElement.TryGetProperty("AppSettings", out JsonElement appSettingsElement))
           {
               var appSettings = new AppSettings();
               
               if (appSettingsElement.TryGetProperty("SiteTitle", out JsonElement siteTitleElement))
               {
                   appSettings.SiteTitle = siteTitleElement.GetString();
               }
               
               if (appSettingsElement.TryGetProperty("EnableCache", out JsonElement enableCacheElement))
               {
                   appSettings.EnableCache = enableCacheElement.GetBoolean();
               }
               
               if (appSettingsElement.TryGetProperty("CacheTimeout", out JsonElement cacheTimeoutElement))
               {
                   appSettings.CacheTimeout = cacheTimeoutElement.GetInt32();
               }
               
               // 保存应用设置配置
               var appSettingsConfig = new Config<AppSettings>();
               appSettingsConfig.Current = appSettings;
               appSettingsConfig.Save();
           }
       }
   }
   ```

4. **更新代码引用**：将代码中的 IConfiguration 引用替换为 Pek.Common 配置类

   ```csharp
   // 原始代码
   public class HomeController : Controller
   {
       private readonly IConfiguration _configuration;
       
       public HomeController(IConfiguration configuration)
       {
           _configuration = configuration;
       }
       
       public IActionResult Index()
       {
           string siteTitle = _configuration["AppSettings:SiteTitle"];
           bool enableCache = bool.Parse(_configuration["AppSettings:EnableCache"]);
           int cacheTimeout = int.Parse(_configuration["AppSettings:CacheTimeout"]);
           
           // ...
       }
   }
   
   // 迁移后的代码
   public class HomeController : Controller
   {
       private readonly AppSettings _appSettings;
       
       public HomeController(Config<AppSettings> appSettingsConfig)
       {
           _appSettings = appSettingsConfig.Current;
       }
       
       public IActionResult Index()
       {
           string siteTitle = _appSettings.SiteTitle;
           bool enableCache = _appSettings.EnableCache;
           int cacheTimeout = _appSettings.CacheTimeout;
           
           // ...
       }
   }
   ```

5. **注册配置服务**：在依赖注入容器中注册 Pek.Common 配置服务

   ```csharp
   public class Startup
   {
       public void ConfigureServices(IServiceCollection services)
       {
           // 注册配置
           services.AddSingleton<Config<LoggingSettings>>();
           services.AddSingleton<Config<ConnectionStrings>>();
           services.AddSingleton<Config<AppSettings>>();
           
           // 注册配置实例
           services.AddSingleton(provider => provider.GetRequiredService<Config<LoggingSettings>>().Current);
           services.AddSingleton(provider => provider.GetRequiredService<Config<ConnectionStrings>>().Current);
           services.AddSingleton(provider => provider.GetRequiredService<Config<AppSettings>>().Current);
           
           // 其他服务注册
           services.AddControllers();
       }
   }
   ```

#### 2.1.2 迁移示例

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        // 迁移配置
        ConfigMigrator.MigrateFromAppSettings("appsettings.json");
        
        // 创建主机
        CreateHostBuilder(args).Build().Run();
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =>
            {
                // 注册配置
                services.AddSingleton<Config<LoggingSettings>>();
                services.AddSingleton<Config<ConnectionStrings>>();
                services.AddSingleton<Config<AppSettings>>();
                
                // 注册配置实例
                services.AddSingleton(provider => provider.GetRequiredService<Config<LoggingSettings>>().Current);
                services.AddSingleton(provider => provider.GetRequiredService<Config<ConnectionStrings>>().Current);
                services.AddSingleton(provider => provider.GetRequiredService<Config<AppSettings>>().Current);
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

### 2.2 从 Web.config 迁移

#### 2.2.1 迁移步骤

1. **分析现有配置**：分析 Web.config 文件的结构和内容

   ```xml
   <!-- 原始 Web.config -->
   <configuration>
     <appSettings>
       <add key="SiteTitle" value="My Application" />
       <add key="EnableCache" value="true" />
       <add key="CacheTimeout" value="3600" />
     </appSettings>
     <connectionStrings>
       <add name="DefaultConnection" connectionString="Server=localhost;Database=myDb;User=sa;Password=yourPassword;" providerName="System.Data.SqlClient" />
     </connectionStrings>
     <system.web>
       <compilation debug="true" targetFramework="4.8" />
       <httpRuntime targetFramework="4.8" />
     </system.web>
   </configuration>
   ```

2. **创建配置类**：为每个配置部分创建强类型配置类

   ```csharp
   public class AppSettings
   {
       public string SiteTitle { get; set; } = "My Application";
       public bool EnableCache { get; set; } = true;
       public int CacheTimeout { get; set; } = 3600;
   }
   
   public class ConnectionStrings
   {
       public string DefaultConnection { get; set; } = "";
   }
   ```

3. **迁移配置数据**：将 Web.config 中的数据转换为 Pek.Common 配置格式

   ```csharp
   public class ConfigMigrator
   {
       public static void MigrateFromWebConfig(string webConfigPath)
       {
           // 加载 Web.config
           var webConfig = new ExeConfigurationFileMap { ExeConfigFilename = webConfigPath };
           var config = ConfigurationManager.OpenMappedExeConfiguration(webConfig, ConfigurationUserLevel.None);
           
           // 迁移应用设置
           var appSettings = new AppSettings();
           
           appSettings.SiteTitle = config.AppSettings.Settings["SiteTitle"]?.Value ?? appSettings.SiteTitle;
           
           if (bool.TryParse(config.AppSettings.Settings["EnableCache"]?.Value, out bool enableCache))
           {
               appSettings.EnableCache = enableCache;
           }
           
           if (int.TryParse(config.AppSettings.Settings["CacheTimeout"]?.Value, out int cacheTimeout))
           {
               appSettings.CacheTimeout = cacheTimeout;
           }
           
           // 保存应用设置配置
           var appSettingsConfig = new Config<AppSettings>();
           appSettingsConfig.Current = appSettings;
           appSettingsConfig.Save();
           
           // 迁移连接字符串
           var connectionStrings = new ConnectionStrings();
           
           connectionStrings.DefaultConnection = config.ConnectionStrings.ConnectionStrings["DefaultConnection"]?.ConnectionString ?? "";
           
           // 保存连接字符串配置
           var connectionStringsConfig = new Config<ConnectionStrings>();
           connectionStringsConfig.Current = connectionStrings;
           connectionStringsConfig.Save();
       }
   }
   ```

4. **更新代码引用**：将代码中的 ConfigurationManager 引用替换为 Pek.Common 配置类

   ```csharp
   // 原始代码
   public class HomeController : Controller
   {
       public ActionResult Index()
       {
           string siteTitle = ConfigurationManager.AppSettings["SiteTitle"];
           bool enableCache = bool.Parse(ConfigurationManager.AppSettings["EnableCache"]);
           int cacheTimeout = int.Parse(ConfigurationManager.AppSettings["CacheTimeout"]);
           string connectionString = ConfigurationManager.ConnectionStrings["DefaultConnection"].ConnectionString;
           
           // ...
       }
   }
   
   // 迁移后的代码
   public class HomeController : Controller
   {
       private readonly AppSettings _appSettings;
       private readonly ConnectionStrings _connectionStrings;
       
       public HomeController(Config<AppSettings> appSettingsConfig, Config<ConnectionStrings> connectionStringsConfig)
       {
           _appSettings = appSettingsConfig.Current;
           _connectionStrings = connectionStringsConfig.Current;
       }
       
       public ActionResult Index()
       {
           string siteTitle = _appSettings.SiteTitle;
           bool enableCache = _appSettings.EnableCache;
           int cacheTimeout = _appSettings.CacheTimeout;
           string connectionString = _connectionStrings.DefaultConnection;
           
           // ...
       }
   }
   ```

5. **注册配置服务**：在依赖注入容器中注册 Pek.Common 配置服务

   ```csharp
   public class Startup
   {
       public void ConfigureServices(IServiceCollection services)
       {
           // 注册配置
           services.AddSingleton<Config<AppSettings>>();
           services.AddSingleton<Config<ConnectionStrings>>();
           
           // 注册配置实例
           services.AddSingleton(provider => provider.GetRequiredService<Config<AppSettings>>().Current);
           services.AddSingleton(provider => provider.GetRequiredService<Config<ConnectionStrings>>().Current);
           
           // 其他服务注册
           services.AddControllers();
       }
   }
   ```

#### 2.2.2 迁移示例

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        // 迁移配置
        ConfigMigrator.MigrateFromWebConfig("Web.config");
        
        // 创建主机
        CreateHostBuilder(args).Build().Run();
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =>
            {
                // 注册配置
                services.AddSingleton<Config<AppSettings>>();
                services.AddSingleton<Config<ConnectionStrings>>();
                
                // 注册配置实例
                services.AddSingleton(provider => provider.GetRequiredService<Config<AppSettings>>().Current);
                services.AddSingleton(provider => provider.GetRequiredService<Config<ConnectionStrings>>().Current);
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

### 2.3 从自定义配置系统迁移

#### 2.3.1 迁移步骤

1. **分析现有配置**：分析自定义配置系统的结构和内容

2. **创建配置类**：为每个配置部分创建强类型配置类

   ```csharp
   public class CustomSettings
   {
       public string Setting1 { get; set; } = "";
       public int Setting2 { get; set; } = 0;
       public bool Setting3 { get; set; } = false;
       public List<string> Setting4 { get; set; } = new List<string>();
   }
   ```

3. **创建迁移适配器**：实现从自定义配置系统到 Pek.Common 配置系统的适配器

   ```csharp
   public class CustomConfigAdapter
   {
       private readonly ICustomConfig _customConfig;
       
       public CustomConfigAdapter(ICustomConfig customConfig)
       {
           _customConfig = customConfig;
       }
       
       public CustomSettings GetCustomSettings()
       {
           var settings = new CustomSettings();
           
           settings.Setting1 = _customConfig.GetString("Setting1");
           settings.Setting2 = _customConfig.GetInt("Setting2");
           settings.Setting3 = _customConfig.GetBool("Setting3");
           settings.Setting4 = _customConfig.GetStringList("Setting4");
           
           return settings;
       }
       
       public void SaveCustomSettings(CustomSettings settings)
       {
           _customConfig.SetString("Setting1", settings.Setting1);
           _customConfig.SetInt("Setting2", settings.Setting2);
           _customConfig.SetBool("Setting3", settings.Setting3);
           _customConfig.SetStringList("Setting4", settings.Setting4);
           
           _customConfig.Save();
       }
   }
   ```

4. **迁移配置数据**：使用适配器将自定义配置系统中的数据转换为 Pek.Common 配置格式

   ```csharp
   public class ConfigMigrator
   {
       public static void MigrateFromCustomConfig(ICustomConfig customConfig)
       {
           var adapter = new CustomConfigAdapter(customConfig);
           var customSettings = adapter.GetCustomSettings();
           
           // 保存到 Pek.Common 配置系统
           var config = new Config<CustomSettings>();
           config.Current = customSettings;
           config.Save();
       }
   }
   ```

5. **更新代码引用**：将代码中的自定义配置系统引用替换为 Pek.Common 配置类

   ```csharp
   // 原始代码
   public class CustomService
   {
       private readonly ICustomConfig _customConfig;
       
       public CustomService(ICustomConfig customConfig)
       {
           _customConfig = customConfig;
       }
       
       public void DoSomething()
       {
           string setting1 = _customConfig.GetString("Setting1");
           int setting2 = _customConfig.GetInt("Setting2");
           bool setting3 = _customConfig.GetBool("Setting3");
           List<string> setting4 = _customConfig.GetStringList("Setting4");
           
           // ...
       }
   }
   
   // 迁移后的代码
   public class CustomService
   {
       private readonly CustomSettings _settings;
       
       public CustomService(Config<CustomSettings> config)
       {
           _settings = config.Current;
       }
       
       public void DoSomething()
       {
           string setting1 = _settings.Setting1;
           int setting2 = _settings.Setting2;
           bool setting3 = _settings.Setting3;
           List<string> setting4 = _settings.Setting4;
           
           // ...
       }
   }
   ```

6. **注册配置服务**：在依赖注入容器中注册 Pek.Common 配置服务

   ```csharp
   public class Startup
   {
       public void ConfigureServices(IServiceCollection services)
       {
           // 注册配置
           services.AddSingleton<Config<CustomSettings>>();
           
           // 注册配置实例
           services.AddSingleton(provider => provider.GetRequiredService<Config<CustomSettings>>().Current);
           
           // 其他服务注册
           services.AddControllers();
       }
   }
   ```

#### 2.3.2 迁移示例

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        // 获取自定义配置实例
        var customConfig = CustomConfigFactory.Create();
        
        // 迁移配置
        ConfigMigrator.MigrateFromCustomConfig(customConfig);
        
        // 创建主机
        CreateHostBuilder(args).Build().Run();
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =>
            {
                // 注册配置
                services.AddSingleton<Config<CustomSettings>>();
                
                // 注册配置实例
                services.AddSingleton(provider => provider.GetRequiredService<Config<CustomSettings>>().Current);
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

## 3. 迁移策略

### 3.1 渐进式迁移

渐进式迁移是一种逐步迁移配置系统的方法，适用于大型应用程序或无法一次性完成迁移的情况。

#### 3.1.1 渐进式迁移步骤

1. **识别配置模块**：将配置系统分解为独立的模块

2. **优先级排序**：确定模块迁移的优先级

3. **创建适配层**：实现适配层，同时支持旧配置系统和新配置系统

   ```csharp
   public class ConfigAdapter
   {
       private readonly IConfiguration _oldConfig;
       private readonly Dictionary<Type, object> _newConfigs = new Dictionary<Type, object>();
       
       public ConfigAdapter(IConfiguration oldConfig)
       {
           _oldConfig = oldConfig;
       }
       
       public void RegisterConfig<TConfig>(Config<TConfig> config) where TConfig : class, new()
       {
           _newConfigs[typeof(TConfig)] = config;
       }
       
       public TConfig GetConfig<TConfig>() where TConfig : class, new()
       {
           if (_newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               return ((Config<TConfig>)configObj).Current;
           }
           
           return null;
       }
       
       public string GetValue(string key)
       {
           return _oldConfig[key];
       }
       
       public T GetValue<T>(string key, T defaultValue = default)
       {
           return _oldConfig.GetValue<T>(key, defaultValue);
       }
   }
   ```

4. **逐步迁移模块**：按照优先级逐步迁移每个模块

5. **验证和测试**：验证每个模块的迁移结果

6. **移除适配层**：完成所有模块的迁移后，移除适配层

#### 3.1.2 渐进式迁移示例

```csharp
public class Startup
{
    private readonly IConfiguration _configuration;
    private readonly ConfigAdapter _configAdapter;
    
    public Startup(IConfiguration configuration)
    {
        _configuration = configuration;
        _configAdapter = new ConfigAdapter(configuration);
    }
    
    public void ConfigureServices(IServiceCollection services)
    {
        // 注册适配器
        services.AddSingleton(_configAdapter);
        
        // 迁移第一个模块：应用设置
        var appSettingsConfig = new Config<AppSettings>();
        appSettingsConfig.Load();
        _configAdapter.RegisterConfig(appSettingsConfig);
        services.AddSingleton(appSettingsConfig);
        services.AddSingleton(appSettingsConfig.Current);
        
        // 其他模块仍然使用旧配置系统
        // ...
        
        // 注册服务
        services.AddControllers();
    }
}

// 使用适配器的服务
public class AppService
{
    private readonly ConfigAdapter _configAdapter;
    
    public AppService(ConfigAdapter configAdapter)
    {
        _configAdapter = configAdapter;
    }
    
    public void DoSomething()
    {
        // 使用新配置系统（已迁移的模块）
        var appSettings = _configAdapter.GetConfig<AppSettings>();
        if (appSettings != null)
        {
            string siteTitle = appSettings.SiteTitle;
            // ...
        }
        
        // 使用旧配置系统（未迁移的模块）
        string connectionString = _configAdapter.GetValue("ConnectionStrings:DefaultConnection");
        // ...
    }
}
```

### 3.2 并行运行策略

并行运行策略是一种同时运行旧配置系统和新配置系统的方法，适用于需要验证新配置系统的正确性或需要平滑过渡的情况。

#### 3.2.1 并行运行步骤

1. **实现配置同步器**：确保两个配置系统的数据同步

   ```csharp
   public class ConfigSynchronizer
   {
       private readonly IConfiguration _oldConfig;
       private readonly Dictionary<Type, object> _newConfigs = new Dictionary<Type, object>();
       
       public ConfigSynchronizer(IConfiguration oldConfig)
       {
           _oldConfig = oldConfig;
       }
       
       public void RegisterConfig<TConfig>(Config<TConfig> config) where TConfig : class, new()
       {
           _newConfigs[typeof(TConfig)] = config;
       }
       
       public void SyncToNewConfig<TConfig>(Func<IConfiguration, TConfig> mapper) where TConfig : class, new()
       {
           if (_newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               var config = (Config<TConfig>)configObj;
               config.Current = mapper(_oldConfig);
               config.Save();
           }
       }
       
       public void SyncToOldConfig<TConfig>(Action<TConfig, IConfigurationBuilder> mapper) where TConfig : class, new()
       {
           if (_newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               var config = (Config<TConfig>)configObj;
               var builder = new ConfigurationBuilder();
               mapper(config.Current, builder);
               
               // 更新旧配置系统（实际实现取决于旧配置系统的特性）
               // ...
           }
       }
   }
   ```

2. **配置验证器**：验证两个配置系统的一致性

   ```csharp
   public class ConfigValidator
   {
       private readonly IConfiguration _oldConfig;
       private readonly Dictionary<Type, object> _newConfigs = new Dictionary<Type, object>();
       
       public ConfigValidator(IConfiguration oldConfig)
       {
           _oldConfig = oldConfig;
       }
       
       public void RegisterConfig<TConfig>(Config<TConfig> config) where TConfig : class, new()
       {
           _newConfigs[typeof(TConfig)] = config;
       }
       
       public bool Validate<TConfig>(Func<IConfiguration, TConfig, bool> validator) where TConfig : class, new()
       {
           if (_newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               var config = (Config<TConfig>)configObj;
               return validator(_oldConfig, config.Current);
           }
           
           return false;
       }
       
       public Dictionary<string, bool> ValidateAll<TConfig>(Dictionary<string, Func<IConfiguration, TConfig, bool>> validators) where TConfig : class, new()
       {
           var results = new Dictionary<string, bool>();
           
           if (_newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               var config = (Config<TConfig>)configObj;
               
               foreach (var validator in validators)
               {
                   results[validator.Key] = validator.Value(_oldConfig, config.Current);
               }
           }
           
           return results;
       }
   }
   ```

3. **切换机制**：实现配置系统的切换机制

   ```csharp
   public class ConfigSwitcher
   {
       private readonly Dictionary<Type, bool> _useNewConfig = new Dictionary<Type, bool>();
       
       public void SetUseNewConfig<TConfig>(bool useNewConfig)
       {
           _useNewConfig[typeof(TConfig)] = useNewConfig;
       }
       
       public bool ShouldUseNewConfig<TConfig>()
       {
           return _useNewConfig.TryGetValue(typeof(TConfig), out bool useNewConfig) && useNewConfig;
       }
   }
   ```

4. **配置工厂**：创建统一的配置访问接口

   ```csharp
   public class ConfigFactory
   {
       private readonly IConfiguration _oldConfig;
       private readonly Dictionary<Type, object> _newConfigs = new Dictionary<Type, object>();
       private readonly ConfigSwitcher _switcher;
       
       public ConfigFactory(IConfiguration oldConfig, ConfigSwitcher switcher)
       {
           _oldConfig = oldConfig;
           _switcher = switcher;
       }
       
       public void RegisterConfig<TConfig>(Config<TConfig> config) where TConfig : class, new()
       {
           _newConfigs[typeof(TConfig)] = config;
       }
       
       public TConfig GetConfig<TConfig>() where TConfig : class, new()
       {
           if (_switcher.ShouldUseNewConfig<TConfig>() && _newConfigs.TryGetValue(typeof(TConfig), out object configObj))
           {
               return ((Config<TConfig>)configObj).Current;
           }
           else
           {
               // 从旧配置系统获取配置
               // 实际实现取决于旧配置系统的特性和配置类的结构
               // ...
               return null;
           }
       }
   }
   ```

#### 3.2.2 并行运行示例

```csharp
public class Startup
{
    private readonly IConfiguration _configuration;
    private readonly ConfigSwitcher _configSwitcher;
    private readonly ConfigFactory _configFactory;
    
    public Startup(IConfiguration configuration)
    {
        _configuration = configuration;
        _configSwitcher = new ConfigSwitcher();
        _configFactory = new ConfigFactory(configuration, _configSwitcher);
    }
    
    public void ConfigureServices(IServiceCollection services)
    {
        // 注册配置切换器和工厂
        services.AddSingleton(_configSwitcher);
        services.AddSingleton(_configFactory);
        
        // 注册新配置系统
        var appSettingsConfig = new Config<AppSettings>();
        appSettingsConfig.Load();
        _configFactory.RegisterConfig(appSettingsConfig);
        
        // 默认使用旧配置系统
        _configSwitcher.SetUseNewConfig<AppSettings>(false);
        
        // 注册服务
        services.AddControllers();
    }
}

// 使用配置工厂的服务
public class AppService
{
    private readonly ConfigFactory _configFactory;
    private readonly ConfigSwitcher _configSwitcher;
    
    public AppService(ConfigFactory configFactory, ConfigSwitcher configSwitcher)
    {
        _configFactory = configFactory;
        _configSwitcher = configSwitcher;
    }
    
    public void DoSomething()
    {
        // 获取配置（根据切换器决定使用哪个配置系统）
        var appSettings = _configFactory.GetConfig<AppSettings>();
        
        // 使用配置
        string siteTitle = appSettings.SiteTitle;
        // ...
    }
    
    public void SwitchToNewConfig()
    {
        // 切换到新配置系统
        _configSwitcher.SetUseNewConfig<AppSettings>(true);
    }
}
```

### 3.3 一次性迁移

一次性迁移是一种在特定时间点完全替换配置系统的方法，适用于简单应用程序或可以接受短暂停机的情况。

#### 3.3.1 一次性迁移步骤

1. **准备迁移脚本**：创建将旧配置系统数据转换为新配置系统格式的脚本

2. **创建备份**：备份旧配置系统的数据

3. **执行迁移**：在应用程序停机期间执行迁移脚本

4. **更新代码**：更新所有代码以使用新配置系统

5. **验证迁移**：验证迁移结果的正确性

6. **启动应用程序**：使用新配置系统启动应用程序

#### 3.3.2 一次性迁移示例

```csharp
public class ConfigMigrator
{
    public static void MigrateAll(string appSettingsPath, string webConfigPath)
    {
        // 备份旧配置文件
        File.Copy(appSettingsPath, appSettingsPath + ".bak", true);
        File.Copy(webConfigPath, webConfigPath + ".bak", true);
        
        // 迁移 appsettings.json
        MigrateFromAppSettings(appSettingsPath);
        
        // 迁移 Web.config
        MigrateFromWebConfig(webConfigPath);
        
        // 验证迁移结果
        ValidateMigration(appSettingsPath, webConfigPath);
    }
    
    private static void MigrateFromAppSettings(string appSettingsPath)
    {
        // 实现从 appsettings.json 迁移的逻辑
        // ...
    }
    
    private static void MigrateFromWebConfig(string webConfigPath)
    {
        // 实现从 Web.config 迁移的逻辑
        // ...
    }
    
    private static void ValidateMigration(string appSettingsPath, string webConfigPath)
    {
        // 实现验证迁移结果的逻辑
        // ...
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        // 执行迁移
        ConfigMigrator.MigrateAll("appsettings.json", "Web.config");
        
        // 创建主机（使用新配置系统）
        CreateHostBuilder(args).Build().Run();
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =>
            {
                // 注册新配置系统
                services.AddSingleton<Config<AppSettings>>();
                services.AddSingleton<Config<ConnectionStrings>>();
                
                // 注册配置实例
                services.AddSingleton(provider => provider.GetRequiredService<Config<AppSettings>>().Current);
                services.AddSingleton(provider => provider.GetRequiredService<Config<ConnectionStrings>>().Current);
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

## 4. 迁移后的优化

### 4.1 配置结构优化

迁移完成后，可以优化配置结构以更好地利用 Pek.Common 配置系统的特性。

#### 4.1.1 配置分组

将相关的配置项分组到专用的配置类中，提高代码的可读性和可维护性。

```csharp
// 原始配置类
public class AppSettings
{
    public string SiteTitle { get; set; } = "My Application";
    public bool EnableCache { get; set; } = true;
    public int CacheTimeout { get; set; } = 3600;
    public string SmtpServer { get; set; } = "smtp.example.com";
    public int SmtpPort { get; set; } = 25;
    public string SmtpUsername { get; set; } = "";
    public string SmtpPassword { get; set; } = "";
}

// 优化后的配置类
public class AppSettings
{
    public string SiteTitle { get; set; } = "My Application";
    public CacheSettings Cache { get; set; } = new CacheSettings();
    public EmailSettings Email { get; set; } = new EmailSettings();
}

public class CacheSettings
{
    public bool Enabled { get; set; } = true;
    public int TimeoutSeconds { get; set; } = 3600;
}

public class EmailSettings
{
    public string SmtpServer { get; set; } = "smtp.example.com";
    public int SmtpPort { get; set; } = 25;
    public string Username { get; set; } = "";
    public string Password { get; set; } = "";
}
```

#### 4.1.2 配置验证

添加配置验证逻辑，确保配置数据的有效性。

```csharp
public class AppSettings
{
    [Required]
    public string SiteTitle { get; set; } = "My Application";
    
    public CacheSettings Cache { get; set; } = new CacheSettings();
    public EmailSettings Email { get; set; } = new EmailSettings();
    
    public bool Validate()
    {
        if (string.IsNullOrEmpty(SiteTitle))
        {
            return false;
        }
        
        return Cache.Validate() && Email.Validate();
    }
}

public class CacheSettings
{
    public bool Enabled { get; set; } = true;
    
    [Range(1, 86400)]
    public int TimeoutSeconds { get; set; } = 3600;
    
    public bool Validate()
    {
        return TimeoutSeconds >= 1 && TimeoutSeconds <= 86400;
    }
}

public class EmailSettings
{
    [Required]
    public string SmtpServer { get; set; } = "smtp.example.com";
    
    [Range(1, 65535)]
    public int SmtpPort { get; set; } = 25;
    
    public string Username { get; set; } = "";
    public string Password { get; set; } = "";
    
    public bool Validate()
    {
        if (string.IsNullOrEmpty(SmtpServer))
        {
            return false;
        }
        
        if (SmtpPort < 1 || SmtpPort > 65535)
        {
            return false;
        }
        
        return true;
    }
}
```

#### 4.1.3 配置默认值

为配置项提供合理的默认值，减少配置错误的可能性。

```csharp
public class AppSettings
{
    public string SiteTitle { get; set; } = "My Application";
    public CacheSettings Cache { get; set; } = new CacheSettings();
    public EmailSettings Email { get; set; } = new EmailSettings();
    
    public static AppSettings CreateDefault()
    {
        return new AppSettings
        {
            SiteTitle = "My Application",
            Cache = CacheSettings.CreateDefault(),
            Email = EmailSettings.CreateDefault()
        };
    }
}

public class CacheSettings
{
    public bool Enabled { get; set; } = true;
    public int TimeoutSeconds { get; set; } = 3600;
    
    public static CacheSettings CreateDefault()
    {
        return new CacheSettings
        {
            Enabled = true,
            TimeoutSeconds = 3600
        };
    }
}

public class EmailSettings
{
    public string SmtpServer { get; set; } = "smtp.example.com";
    public int SmtpPort { get; set; } = 25;
    public string Username { get; set; } = "";
    public string Password { get; set; } = "";
    
    public static EmailSettings CreateDefault()
    {
        return new EmailSettings
        {
            SmtpServer = "smtp.example.com",
            SmtpPort = 25,
            Username = "",
            Password = ""
        };
    }
}
```

### 4.2 性能优化

优化配置系统的性能，减少资源消耗和提高响应速度。

#### 4.2.1 延迟加载

实现配置的延迟加载，仅在需要时加载配置数据。

```csharp
public class LazyConfig<TConfig> where TConfig : class, new()
{
    private readonly Lazy<Config<TConfig>> _lazyConfig;
    
    public LazyConfig()
    {
        _lazyConfig = new Lazy<Config<TConfig>>(() =>
        {
            var config = new Config<TConfig>();
            config.Load();
            return config;
        });
    }
    
    public Config<TConfig> Value => _lazyConfig.Value;
    
    public TConfig Current => Value.Current;
    
    public void Save()
    {
        Value.Save();
    }
}
```

#### 4.2.2 配置缓存

实现配置缓存，减少配置文件的读取次数。

```csharp
public class CachedConfig<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    private readonly TimeSpan _cacheTimeout;
    private DateTime _lastLoadTime;
    
    public CachedConfig(TimeSpan cacheTimeout)
    {
        _config = new Config<TConfig>();
        _cacheTimeout = cacheTimeout;
        _lastLoadTime = DateTime.MinValue;
    }
    
    public TConfig Current
    {
        get
        {
            if (DateTime.Now - _lastLoadTime > _cacheTimeout)
            {
                _config.Load();
                _lastLoadTime = DateTime.Now;
            }
            
            return _config.Current;
        }
    }
    
    public void Save()
    {
        _config.Save();
        _lastLoadTime = DateTime.Now;
    }
}
```

#### 4.2.3 异步操作

实现配置的异步加载和保存，避免阻塞主线程。

```csharp
public class AsyncConfig<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    
    public AsyncConfig()
    {
        _config = new Config<TConfig>();
    }
    
    public TConfig Current => _config.Current;
    
    public async Task LoadAsync()
    {
        await Task.Run(() => _config.Load());
    }
    
    public async Task SaveAsync()
    {
        await Task.Run(() => _config.Save());
    }
}
```

### 4.3 安全性优化

提高配置系统的安全性，保护敏感配置数据。

#### 4.3.1 配置加密

实现配置数据的加密，保护敏感信息。

```csharp
public class EncryptedConfig<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    private readonly IEncryptionService _encryptionService;
    
    public EncryptedConfig(IEncryptionService encryptionService)
    {
        _config = new Config<TConfig>();
        _encryptionService = encryptionService;
    }
    
    public TConfig Current => _config.Current;
    
    public void Load()
    {
        _config.Load();
        DecryptProperties(_config.Current);
    }
    
    public void Save()
    {
        EncryptProperties(_config.Current);
        _config.Save();
        DecryptProperties(_config.Current);
    }
    
    private void EncryptProperties(TConfig config)
    {
        // 加密敏感属性
        // ...
    }
    
    private void DecryptProperties(TConfig config)
    {
        // 解密敏感属性
        // ...
    }
}

public interface IEncryptionService
{
    string Encrypt(string plainText);
    string Decrypt(string cipherText);
}
```

#### 4.3.2 访问控制

实现配置的访问控制，限制对敏感配置的访问。

```csharp
public class SecureConfig<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    private readonly IAuthorizationService _authorizationService;
    
    public SecureConfig(IAuthorizationService authorizationService)
    {
        _config = new Config<TConfig>();
        _authorizationService = authorizationService;
    }
    
    public TConfig GetCurrent(string userId, string role)
    {
        if (_authorizationService.CanAccess(userId, role, typeof(TConfig).Name))
        {
            return _config.Current;
        }
        
        throw new UnauthorizedAccessException($"User {userId} with role {role} is not authorized to access {typeof(TConfig).Name} configuration.");
    }
    
    public void Save(string userId, string role)
    {
        if (_authorizationService.CanModify(userId, role, typeof(TConfig).Name))
        {
            _config.Save();
        }
        else
        {
            throw new UnauthorizedAccessException($"User {userId} with role {role} is not authorized to modify {typeof(TConfig).Name} configuration.");
        }
    }
}

public interface IAuthorizationService
{
    bool CanAccess(string userId, string role, string configName);
    bool CanModify(string userId, string role, string configName);
}
```

## 5. 迁移测试和验证

### 5.1 单元测试

为迁移后的配置系统编写单元测试，验证其功能的正确性。

```csharp
public class ConfigTests
{
    [Fact]
    public void TestAppSettingsConfig()
    {
        // 创建测试配置
        var config = new Config<AppSettings>();
        config.Current.SiteTitle = "Test Application";
        config.Current.Cache.Enabled = true;
        config.Current.Cache.TimeoutSeconds = 1800;
        
        // 保存配置
        config.Save();
        
        // 重新加载配置
        var newConfig = new Config<AppSettings>();
        newConfig.Load();
        
        // 验证配置
        Assert.Equal("Test Application", newConfig.Current.SiteTitle);
        Assert.True(newConfig.Current.Cache.Enabled);
        Assert.Equal(1800, newConfig.Current.Cache.TimeoutSeconds);
    }
    
    [Fact]
    public void TestConnectionStringsConfig()
    {
        // 创建测试配置
        var config = new Config<ConnectionStrings>();
        config.Current.DefaultConnection = "Server=testserver;Database=testdb;User=testuser;Password=testpassword;";
        
        // 保存配置
        config.Save();
        
        // 重新加载配置
        var newConfig = new Config<ConnectionStrings>();
        newConfig.Load();
        
        // 验证配置
        Assert.Equal("Server=testserver;Database=testdb;User=testuser;Password=testpassword;", newConfig.Current.DefaultConnection);
    }
}
```

### 5.2 集成测试

编写集成测试，验证配置系统与应用程序其他部分的集成。

```csharp
public class ConfigIntegrationTests
{
    [Fact]
    public void TestAppServiceWithConfig()
    {
        // 创建测试配置
        var config = new Config<AppSettings>();
        config.Current.SiteTitle = "Test Application";
        config.Current.Cache.Enabled = true;
        config.Current.Cache.TimeoutSeconds = 1800;
        config.Save();
        
        // 创建服务
        var appService = new AppService(config);
        
        // 测试服务
        string siteTitle = appService.GetSiteTitle();
        bool cacheEnabled = appService.IsCacheEnabled();
        int cacheTimeout = appService.GetCacheTimeout();
        
        // 验证结果
        Assert.Equal("Test Application", siteTitle);
        Assert.True(cacheEnabled);
        Assert.Equal(1800, cacheTimeout);
    }
    
    [Fact]
    public void TestDatabaseServiceWithConfig()
    {
        // 创建测试配置
        var config = new Config<ConnectionStrings>();
        config.Current.DefaultConnection = "Server=testserver;Database=testdb;User=testuser;Password=testpassword;";
        config.Save();
        
        // 创建服务
        var databaseService = new DatabaseService(config);
        
        // 测试服务
        string connectionString = databaseService.GetConnectionString();
        
        // 验证结果
        Assert.Equal("Server=testserver;Database=testdb;User=testuser;Password=testpassword;", connectionString);
    }
}
```

### 5.3 性能测试

编写性能测试，验证配置系统的性能特性。

```csharp
public class ConfigPerformanceTests
{
    [Fact]
    public void TestConfigLoadPerformance()
    {
        // 创建测试配置
        var config = new Config<AppSettings>();
        config.Current.SiteTitle = "Test Application";
        config.Save();
        
        // 测试加载性能
        var stopwatch = Stopwatch.StartNew();
        
        for (int i = 0; i < 1000; i++)
        {
            var newConfig = new Config<AppSettings>();
            newConfig.Load();
        }
        
        stopwatch.Stop();
        
        // 验证性能
        Assert.True(stopwatch.ElapsedMilliseconds < 5000, $"Loading config 1000 times took {stopwatch.ElapsedMilliseconds}ms, which exceeds the 5000ms threshold.");
    }
    
    [Fact]
    public void TestConfigSavePerformance()
    {
        // 创建测试配置
        var config = new Config<AppSettings>();
        
        // 测试保存性能
        var stopwatch = Stopwatch.StartNew();
        
        for (int i = 0; i < 100; i++)
        {
            config.Current.SiteTitle = $"Test Application {i}";
            config.Save();
        }
        
        stopwatch.Stop();
        
        // 验证性能
        Assert.True(stopwatch.ElapsedMilliseconds < 5000, $"Saving config 100 times took {stopwatch.ElapsedMilliseconds}ms, which exceeds the 5000ms threshold.");
    }
}
```

## 6. 常见问题和解决方案

### 6.1 配置数据丢失

**问题**：迁移过程中配置数据丢失。

**解决方案**：
1. 在迁移前创建配置数据的备份
2. 实现配置数据验证机制
3. 使用并行运行策略，确保新旧配置系统的数据一致性

```csharp
public class ConfigBackup
{
    public static void Backup(string configPath, string backupPath)
    {
        if (File.Exists(configPath))
        {
            File.Copy(configPath, backupPath, true);
        }
    }
    
    public static void Restore(string backupPath, string configPath)
    {
        if (File.Exists(backupPath))
        {
            File.Copy(backupPath, configPath, true);
        }
    }
}
```

### 6.2 配置格式不兼容

**问题**：旧配置系统和新配置系统的格式不兼容。

**解决方案**：
1. 实现配置格式转换器
2. 使用适配器模式处理格式差异
3. 在迁移过程中进行格式转换

```csharp
public class ConfigFormatConverter
{
    public static TConfig ConvertFromJson<TConfig>(string json) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(json))
        {
            return new TConfig();
        }
        
        return JsonSerializer.Deserialize<TConfig>(json);
    }
    
    public static TConfig ConvertFromXml<TConfig>(string xml) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(xml))
        {
            return new TConfig();
        }
        
        var serializer = new XmlSerializer(typeof(TConfig));
        using (var reader = new StringReader(xml))
        {
            return (TConfig)serializer.Deserialize(reader);
        }
    }
    
    public static TConfig ConvertFromIni<TConfig>(string ini) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(ini))
        {
            return new TConfig();
        }
        
        var config = new TConfig();
        var lines = ini.Split('\n');
        
        foreach (var line in lines)
        {
            var parts = line.Split('=');
            if (parts.Length == 2)
            {
                var key = parts[0].Trim();
                var value = parts[1].Trim();
                
                var property = typeof(TConfig).GetProperty(key);
                if (property != null)
                {
                    if (property.PropertyType == typeof(string))
                    {
                        property.SetValue(config, value);
                    }
                    else if (property.PropertyType == typeof(int) && int.TryParse(value, out int intValue))
                    {
                        property.SetValue(config, intValue);
                    }
                    else if (property.PropertyType == typeof(bool) && bool.TryParse(value, out bool boolValue))
                    {
                        property.SetValue(config, boolValue);
                    }
                }
            }
        }
        
        return config;
    }
}
```

### 6.3 配置依赖关系

**问题**：配置项之间存在依赖关系，迁移过程中可能破坏这些关系。

**解决方案**：
1. 识别配置项之间的依赖关系
2. 按照依赖顺序进行迁移
3. 实现配置依赖关系验证机制

```csharp
public class ConfigDependencyValidator
{
    public static bool ValidateDependencies<TConfig>(TConfig config) where TConfig : class, new()
    {
        // 获取配置类的所有属性
        var properties = typeof(TConfig).GetProperties();
        
        // 检查每个属性的依赖关系
        foreach (var property in properties)
        {
            var dependsOnAttribute = property.GetCustomAttribute<DependsOnAttribute>();
            if (dependsOnAttribute != null)
            {
                // 获取依赖属性的值
                var dependencyProperty = typeof(TConfig).GetProperty(dependsOnAttribute.PropertyName);
                if (dependencyProperty == null)
                {
                    return false;
                }
                
                var dependencyValue = dependencyProperty.GetValue(config);
                var propertyValue = property.GetValue(config);
                
                // 验证依赖关系
                if (!dependsOnAttribute.Validate(dependencyValue, propertyValue))
                {
                    return false;
                }
            }
        }
        
        return true;
    }
}

[AttributeUsage(AttributeTargets.Property)]
public class DependsOnAttribute : Attribute
{
    public string PropertyName { get; }
    
    public DependsOnAttribute(string propertyName)
    {
        PropertyName = propertyName;
    }
    
    public virtual bool Validate(object dependencyValue, object propertyValue)
    {
        // 默认实现，子类可以重写
        return true;
    }
}
```

### 6.4 配置访问模式变化

**问题**：迁移后配置的访问模式发生变化，导致代码需要大量修改。

**解决方案**：
1. 实现适配器，保持原有的访问模式
2. 使用扩展方法提供兼容性API
3. 逐步更新代码以适应新的访问模式

```csharp
public static class ConfigExtensions
{
    // 为 IConfiguration 提供兼容性扩展方法
    public static string GetString(this IConfiguration configuration, string key, string defaultValue = "")
    {
        return configuration[key] ?? defaultValue;
    }
    
    public static int GetInt(this IConfiguration configuration, string key, int defaultValue = 0)
    {
        if (int.TryParse(configuration[key], out int value))
        {
            return value;
        }
        
        return defaultValue;
    }
    
    public static bool GetBool(this IConfiguration configuration, string key, bool defaultValue = false)
    {
        if (bool.TryParse(configuration[key], out bool value))
        {
            return value;
        }
        
        return defaultValue;
    }
    
    // 为 Config<T> 提供兼容性扩展方法
    public static string GetValue(this Config<AppSettings> config, string key, string defaultValue = "")
    {
        switch (key)
        {
            case "AppSettings:SiteTitle":
                return config.Current.SiteTitle ?? defaultValue;
            case "AppSettings:EnableCache":
                return config.Current.Cache.Enabled.ToString();
            case "AppSettings:CacheTimeout":
                return config.Current.Cache.TimeoutSeconds.ToString();
            default:
                return defaultValue;
        }
    }
}
```

## 7. 迁移工具和自动化

### 7.1 迁移工具

开发迁移工具，自动化迁移过程，减少手动操作的错误。

```csharp
public class ConfigMigrationTool
{
    public static void MigrateAll(string configDirectory, string backupDirectory)
    {
        // 创建备份目录
        Directory.CreateDirectory(backupDirectory);
        
        // 备份配置文件
        foreach (var file in Directory.GetFiles(configDirectory, "*.json"))
        {
            var fileName = Path.GetFileName(file);
            var backupPath = Path.Combine(backupDirectory, fileName);
            File.Copy(file, backupPath, true);
        }
        
        // 迁移 appsettings.json
        var appSettingsPath = Path.Combine(configDirectory, "appsettings.json");
        if (File.Exists(appSettingsPath))
        {
            MigrateFromAppSettings(appSettingsPath);
        }
        
        // 迁移 Web.config
        var webConfigPath = Path.Combine(configDirectory, "Web.config");
        if (File.Exists(webConfigPath))
        {
            MigrateFromWebConfig(webConfigPath);
        }
        
        // 迁移自定义配置文件
        var customConfigPath = Path.Combine(configDirectory, "custom.config");
        if (File.Exists(customConfigPath))
        {
            MigrateFromCustomConfig(customConfigPath);
        }
        
        // 验证迁移结果
        ValidateMigration(configDirectory);
    }
    
    private static void MigrateFromAppSettings(string appSettingsPath)
    {
        // 实现从 appsettings.json 迁移的逻辑
        // ...
    }
    
    private static void MigrateFromWebConfig(string webConfigPath)
    {
        // 实现从 Web.config 迁移的逻辑
        // ...
    }
    
    private static void MigrateFromCustomConfig(string customConfigPath)
    {
        // 实现从自定义配置文件迁移的逻辑
        // ...
    }
    
    private static void ValidateMigration(string configDirectory)
    {
        // 实现验证迁移结果的逻辑
        // ...
    }
}
```

### 7.2 迁移脚本

编写迁移脚本，自动执行迁移过程。

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        if (args.Length < 2)
        {
            Console.WriteLine("Usage: ConfigMigration <configDirectory> <backupDirectory>");
            return;
        }
        
        string configDirectory = args[0];
        string backupDirectory = args[1];
        
        try
        {
            Console.WriteLine($"Starting migration from {configDirectory} with backup to {backupDirectory}");
            
            // 执行迁移
            ConfigMigrationTool.MigrateAll(configDirectory, backupDirectory);
            
            Console.WriteLine("Migration completed successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Migration failed: {ex.Message}");
            Console.WriteLine(ex.StackTrace);
        }
    }
}
```

### 7.3 迁移监控

实现迁移监控机制，跟踪迁移进度和结果。

```csharp
public class MigrationMonitor
{
    private readonly List<MigrationStep> _steps = new List<MigrationStep>();
    private readonly string _logPath;
    
    public MigrationMonitor(string logPath)
    {
        _logPath = logPath;
    }
    
    public void AddStep(string name, Action action)
    {
        _steps.Add(new MigrationStep
        {
            Name = name,
            Action = action,
            Status = MigrationStatus.Pending
        });
    }
    
    public void Execute()
    {
        foreach (var step in _steps)
        {
            try
            {
                LogMessage($"Starting step: {step.Name}");
                step.Action();
                step.Status = MigrationStatus.Success;
                LogMessage($"Step completed successfully: {step.Name}");
            }
            catch (Exception ex)
            {
                step.Status = MigrationStatus.Failed;
                step.Error = ex.Message;
                LogMessage($"Step failed: {step.Name}, Error: {ex.Message}");
                throw;
            }
        }
    }
    
    public MigrationReport GenerateReport()
    {
        return new MigrationReport
        {
            Steps = _steps.ToList(),
            TotalSteps = _steps.Count,
            SuccessSteps = _steps.Count(s => s.Status == MigrationStatus.Success),
            FailedSteps = _steps.Count(s => s.Status == MigrationStatus.Failed),
            PendingSteps = _steps.Count(s => s.Status == MigrationStatus.Pending)
        };
    }
    
    private void LogMessage(string message)
    {
        string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
        File.AppendAllText(_logPath, logMessage + Environment.NewLine);
        Console.WriteLine(logMessage);
    }
}

public class MigrationStep
{
    public string Name { get; set; }
    public Action Action { get; set; }
    public MigrationStatus Status { get; set; }
    public string Error { get; set; }
}

public enum MigrationStatus
{
    Pending,
    Success,
    Failed
}

public class MigrationReport
{
    public List<MigrationStep> Steps { get; set; }
    public int TotalSteps { get; set; }
    public int SuccessSteps { get; set; }
    public int FailedSteps { get; set; }
    public int PendingSteps { get; set; }
}
```

## 8. 总结

### 8.1 迁移核心步骤

1. **准备阶段**
   - 分析现有配置系统
   - 设计迁移策略
   - 创建配置备份

2. **迁移阶段**
   - 创建配置类
   - 转换配置数据
   - 更新代码引用

3. **验证阶段**
   - 测试配置功能
   - 验证数据一致性
   - 监控应用性能

4. **优化阶段**
   - 优化配置结构
   - 提高性能和安全性
   - 完善文档和测试

### 8.2 迁移最佳实践

1. **渐进式迁移**：逐步迁移配置系统，减少风险
2. **数据备份**：在迁移前创建配置数据的备份
3. **验证机制**：实现配置数据验证机制，确保数据的完整性和一致性
4. **兼容性适配**：使用适配器和扩展方法提供兼容性API
5. **自动化工具**：开发迁移工具和脚本，自动化迁移过程
6. **监控和报告**：实现迁移监控机制，跟踪迁移进度和结果
7. **测试覆盖**：编写全面的测试用例，验证迁移结果
8. **文档更新**：更新配置系统的文档，反映迁移后的变化

### 8.3 迁移后的维护

1. **持续监控**：监控配置系统的性能和稳定性
2. **定期备份**：定期备份配置数据，防止数据丢失
3. **版本控制**：使用版本控制系统管理配置文件
4. **更新文档**：及时更新配置系统的文档
5. **培训用户**：培训用户使用新的配置系统

通过遵循本指南中的步骤和最佳实践，您可以成功地将现有配置系统迁移到 Pek.Common 配置系统，充分利用其强类型、易用性和可扩展性等优势，提高应用程序的可维护性和灵活性。