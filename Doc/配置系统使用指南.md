# Pek.Common 配置系统使用指南

## 1. 简介

Pek.Common 配置系统是一个轻量级、类型安全的配置管理框架，旨在简化应用程序配置的创建、访问和管理。本指南将帮助您快速上手使用配置系统。

### 1.1 主要特点

- **类型安全**：使用强类型配置类，避免运行时类型错误
- **简单易用**：简洁的 API，易于集成和使用
- **JSON 序列化**：基于 System.Text.Json 的配置序列化
- **AOT 兼容**：支持在 AOT (Ahead-of-Time) 编译环境中使用
- **线程安全**：支持多线程环境下的安全访问

## 2. 快速入门

### 2.1 创建配置类

创建一个继承自 `Config<TConfig>` 的配置类：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

// 为 AOT 兼容性创建 JsonSerializerContext
[JsonSerializable(typeof(AppConfig))]
public partial class AppConfigJsonContext : JsonSerializerContext
{
}

// 定义配置类
public class AppConfig : Config<AppConfig>
{
    // 配置属性，包含默认值
    public string ApplicationName { get; set; } = "我的应用";
    public bool DebugMode { get; set; } = false;
    public int CacheTimeoutMinutes { get; set; } = 30;

    // 静态构造函数，注册配置
    static AppConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = AppConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<AppConfig>(options);
    }
}
```

### 2.2 访问配置

通过配置类的 `Current` 静态属性访问配置实例：

```csharp
// 获取配置实例
var config = AppConfig.Current;

// 读取配置值
string appName = config.ApplicationName;
bool debugMode = config.DebugMode;
int timeout = config.CacheTimeoutMinutes;

// 输出配置值
Console.WriteLine($"应用名称: {appName}");
Console.WriteLine($"调试模式: {debugMode}");
Console.WriteLine($"缓存超时: {timeout}分钟");
```

### 2.3 修改和保存配置

修改配置属性后，调用 `Save()` 方法保存配置：

```csharp
// 获取配置实例
var config = AppConfig.Current;

// 修改配置
config.ApplicationName = "新应用名称";
config.DebugMode = true;
config.CacheTimeoutMinutes = 15;

// 保存配置
config.Save();
Console.WriteLine("配置已保存");
```

### 2.4 重新加载配置

调用配置类的静态 `Reload()` 方法重新加载配置：

```csharp
// 重新加载配置
AppConfig.Reload();

// 获取重新加载后的配置
var reloadedConfig = AppConfig.Current;
Console.WriteLine($"重新加载后的应用名称: {reloadedConfig.ApplicationName}");
```

## 3. 高级用法

### 3.1 AOT 兼容性配置

在 AOT 环境中，需要在程序启动时预初始化配置类：

```csharp
private static void InitializeConfigs()
{
    try
    {
        // 手动注册配置
        var jsonOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = AppConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<AppConfig>(jsonOptions);

        // 触发初始化
        var config = AppConfig.Current;
        Console.WriteLine("配置初始化成功");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"配置初始化失败: {ex.Message}");
    }
}
```

### 3.2 自定义配置文件名

默认情况下，配置文件名为配置类名加 `.config` 扩展名。您可以在注册配置时指定自定义文件名：

```csharp
static AppConfig()
{
    var options = new JsonSerializerOptions
    {
        TypeInfoResolver = AppConfigJsonContext.Default,
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    // 指定自定义文件名
    ConfigManager.RegisterConfig<AppConfig>(options, "application.config");
}
```

### 3.3 配置验证

通过重写 `Save()` 方法，可以在保存配置前添加验证逻辑：

```csharp
public override void Save()
{
    // 验证配置
    if (string.IsNullOrEmpty(ApplicationName))
    {
        throw new InvalidOperationException("应用名称不能为空");
    }

    if (CacheTimeoutMinutes <= 0)
    {
        throw new InvalidOperationException("缓存超时必须大于0");
    }

    // 调用基类方法
    base.Save();
}
```

### 3.4 复杂类型配置

配置类可以包含复杂类型，如集合、嵌套对象等：

```csharp
// 为 AOT 兼容性注册所有需要的类型
[JsonSerializable(typeof(ComplexConfig))]
[JsonSerializable(typeof(DatabaseSettings))]
[JsonSerializable(typeof(List<string>))]
public partial class ComplexConfigJsonContext : JsonSerializerContext
{
}

// 嵌套配置类
public class DatabaseSettings
{
    public string ConnectionString { get; set; } = "Server=localhost;Database=MyApp;";
    public int CommandTimeout { get; set; } = 30;
    public bool UsePooling { get; set; } = true;
}

// 包含复杂类型的配置类
public class ComplexConfig : Config<ComplexConfig>
{
    public string ApplicationName { get; set; } = "复杂配置应用";
    public List<string> EnabledModules { get; set; } = new List<string> { "Core", "UI" };
    public DatabaseSettings Database { get; set; } = new DatabaseSettings();

    static ComplexConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ComplexConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ComplexConfig>(options);
    }
}
```

### 3.5 异常处理

在访问配置时，建议使用 try-catch 块捕获可能的异常：

```csharp
try
{
    var config = AppConfig.Current;
    // 使用配置...
}
catch (FileNotFoundException ex)
{
    Console.WriteLine($"配置文件不存在: {ex.Message}");
    // 使用默认值或创建新配置
}
catch (JsonException ex)
{
    Console.WriteLine($"配置文件格式错误: {ex.Message}");
    // 处理格式错误
}
catch (Exception ex)
{
    Console.WriteLine($"配置加载失败: {ex.Message}");
    // 处理其他异常
}
```

## 4. 配置文件管理

### 4.1 配置文件位置

配置文件默认保存在应用程序根目录下的 `Config` 文件夹中，文件名格式为 `{配置类名}.config`。例如，`AppConfig` 配置类的配置文件路径为：

```
应用程序根目录/Config/AppConfig.config
```

### 4.2 配置文件格式

配置文件使用 JSON 格式存储，例如：

```json
{
  "applicationName": "我的应用",
  "debugMode": false,
  "cacheTimeoutMinutes": 30
}
```

### 4.3 手动编辑配置文件

您可以手动编辑配置文件，但需要确保 JSON 格式正确。编辑后，调用 `Reload()` 方法重新加载配置：

```csharp
// 手动编辑配置文件后重新加载
AppConfig.Reload();
var config = AppConfig.Current;
```

## 5. 最佳实践

### 5.1 配置类设计

- 为每个配置属性提供合理的默认值
- 使用可空类型表示可选配置项
- 将相关配置分组到专门的配置类中
- 使用适当的命名约定
- 添加详细的文档注释

```csharp
/// <summary>
/// 应用程序配置类
/// </summary>
public class AppConfig : Config<AppConfig>
{
    /// <summary>
    /// 应用程序名称
    /// </summary>
    public string ApplicationName { get; set; } = "我的应用";

    /// <summary>
    /// 调试模式，启用时会输出详细日志
    /// </summary>
    public bool DebugMode { get; set; } = false;

    /// <summary>
    /// 缓存超时时间（分钟），0 表示永不过期
    /// </summary>
    public int CacheTimeoutMinutes { get; set; } = 30;

    // 静态构造函数...
}
```

### 5.2 配置访问模式

- 在应用程序启动时初始化配置
- 避免频繁访问 `Current` 属性，可以将配置实例缓存在局部变量中
- 批量修改配置后再保存，避免频繁保存

```csharp
// 缓存配置实例
var config = AppConfig.Current;

// 批量修改
config.ApplicationName = "新名称";
config.DebugMode = true;
config.CacheTimeoutMinutes = 15;

// 一次性保存
config.Save();
```

### 5.3 错误处理

- 为配置加载和保存添加适当的错误处理
- 在配置加载失败时提供回退机制
- 记录配置相关的错误和警告

```csharp
try
{
    var config = AppConfig.Current;
    // 使用配置...
}
catch (Exception ex)
{
    // 记录错误
    Console.WriteLine($"配置加载失败: {ex.Message}");
    
    // 使用默认配置
    var defaultConfig = new AppConfig();
    // 使用默认配置...
}
```

### 5.4 AOT 兼容性

- 为所有配置类创建 JsonSerializerContext
- 在 JsonSerializerContext 中注册所有需要序列化的类型
- 在程序启动时预初始化配置类

## 6. 常见问题解答

### 6.1 配置文件不存在时会发生什么？

当配置文件不存在时，系统会创建一个新的配置实例，使用配置类中定义的默认值，并在调用 `Save()` 方法时创建配置文件。

### 6.2 如何处理配置文件格式错误？

当配置文件格式错误时，`LoadConfig<TConfig>()` 方法会抛出 `JsonException` 异常。您可以捕获此异常并提供适当的错误处理，如使用默认配置或提示用户。

### 6.3 配置系统是否线程安全？

是的，配置系统使用了线程安全的单例模式和锁机制，确保在多线程环境下安全访问配置。

### 6.4 如何在不同环境中使用不同的配置？

您可以通过以下方式实现多环境配置：

1. 创建环境特定的配置类
2. 根据环境变量选择不同的配置文件
3. 在运行时根据环境覆盖配置值

### 6.5 配置系统是否支持加密？

当前版本的配置系统不直接支持加密，但您可以通过创建自定义 `JsonConverter` 实现敏感配置的加密和解密。

### 6.6 如何监听配置变更？

当前版本的配置系统不直接支持配置变更通知，但您可以通过在配置类中添加事件和在属性设置器中触发事件来实现。

## 7. 示例

### 7.1 基本配置示例

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp
{
    [JsonSerializable(typeof(AppSettings))]
    public partial class AppSettingsJsonContext : JsonSerializerContext
    {
    }

    public class AppSettings : Config<AppSettings>
    {
        public string Title { get; set; } = "我的应用";
        public string Theme { get; set; } = "Light";
        public bool NotificationsEnabled { get; set; } = true;
        public int RefreshIntervalSeconds { get; set; } = 60;

        static AppSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppSettings>(options);
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 获取配置
                var settings = AppSettings.Current;
                Console.WriteLine($"标题: {settings.Title}");
                Console.WriteLine($"主题: {settings.Theme}");
                Console.WriteLine($"通知: {(settings.NotificationsEnabled ? "已启用" : "已禁用")}");
                Console.WriteLine($"刷新间隔: {settings.RefreshIntervalSeconds}秒");

                // 修改配置
                Console.WriteLine("\n修改配置...");
                settings.Title = "我的新应用";
                settings.Theme = "Dark";
                settings.Save();
                Console.WriteLine("配置已保存\n");

                // 重新加载配置
                AppSettings.Reload();
                var reloadedSettings = AppSettings.Current;
                Console.WriteLine("重新加载配置:");
                Console.WriteLine($"标题: {reloadedSettings.Title}");
                Console.WriteLine($"主题: {reloadedSettings.Theme}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"错误: {ex.Message}");
            }
        }
    }
}
```

### 7.2 多配置类示例

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp
{
    // 应用设置配置
    [JsonSerializable(typeof(AppSettings))]
    public partial class AppSettingsJsonContext : JsonSerializerContext
    {
    }

    public class AppSettings : Config<AppSettings>
    {
        public string Title { get; set; } = "我的应用";
        public string Theme { get; set; } = "Light";

        static AppSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppSettings>(options);
        }
    }

    // 用户设置配置
    [JsonSerializable(typeof(UserSettings))]
    public partial class UserSettingsJsonContext : JsonSerializerContext
    {
    }

    public class UserSettings : Config<UserSettings>
    {
        public string Username { get; set; } = "默认用户";
        public bool RememberLogin { get; set; } = false;
        public string Language { get; set; } = "zh-CN";

        static UserSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = UserSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<UserSettings>(options);
        }
    }

    // 使用多配置类
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 获取应用设置
                var appSettings = AppSettings.Current;
                Console.WriteLine($"应用标题: {appSettings.Title}");
                Console.WriteLine($"应用主题: {appSettings.Theme}");

                // 获取用户设置
                var userSettings = UserSettings.Current;
                Console.WriteLine($"用户名: {userSettings.Username}");
                Console.WriteLine($"记住登录: {userSettings.RememberLogin}");
                Console.WriteLine($"语言: {userSettings.Language}");

                // 修改设置
                appSettings.Theme = "Dark";
                appSettings.Save();

                userSettings.Username = "新用户";
                userSettings.Language = "en-US";
                userSettings.Save();

                Console.WriteLine("\n设置已保存");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"错误: {ex.Message}");
            }
        }
    }
}
```

## 8. 总结

Pek.Common 配置系统提供了一种简单、类型安全的方式来管理应用程序配置。通过继承 `Config<TConfig>` 类并定义配置属性，您可以轻松创建自定义配置类，并通过 `Current` 静态属性访问配置实例。

配置系统支持配置的保存、重新加载和自定义序列化选项，并且在 AOT 编译环境中也能正常工作。通过遵循本指南中的最佳实践，您可以有效地使用配置系统，提高应用程序的可配置性和可维护性。