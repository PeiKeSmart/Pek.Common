# Pek.Common 配置系统使用指南

## 1. 简介

Pek.Common 配置系统是一个轻量级、类型安全的配置管理框架，旨在简化应用程序配置的创建、访问和管理。本指南将帮助您快速上手使用配置系统。

### 1.1 主要特点

- **类型安全**：使用强类型配置类，避免运行时类型错误
- **简单易用**：简洁的 API，易于集成和使用
- **JSON 序列化**：基于 System.Text.Json 的配置序列化
- **AOT 兼容**：支持在 AOT (Ahead-of-Time) 编译环境中使用
- **线程安全**：支持多线程环境下的安全访问
- **智能自动重新加载**：支持配置文件外部修改后自动更新内存对象，智能过滤代码保存操作
- **通用配置变更通知**：提供统一的事件管理机制，支持多种订阅方式
- **防抖处理**：避免频繁的文件变更导致多次重新加载

## 2. 快速入门

### 2.1 创建配置类

创建一个继承自 `Config<TConfig>` 的配置类：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

// 为 AOT 兼容性创建 JsonSerializerContext
[JsonSerializable(typeof(AppConfig))]
public partial class AppConfigJsonContext : JsonSerializerContext
{
}

// 定义配置类
public class AppConfig : Config<AppConfig>
{
    // 配置属性，包含默认值
    public string ApplicationName { get; set; } = "我的应用";
    public bool DebugMode { get; set; } = false;
    public int CacheTimeoutMinutes { get; set; } = 30;

    // 静态构造函数，注册配置
    static AppConfig()
    {
        RegisterConfigForAot(AppConfigJsonContext.Default);
    }
}
```

### 2.2 访问配置

通过配置类的 `Current` 静态属性访问配置实例：

```csharp
// 获取配置实例（首次访问时会自动初始化和启用文件监控）
var config = AppConfig.Current;

// 读取配置值
string appName = config.ApplicationName;
bool debugMode = config.DebugMode;
int timeout = config.CacheTimeoutMinutes;

// 输出配置值
Console.WriteLine($"应用名称: {appName}");
Console.WriteLine($"调试模式: {debugMode}");
Console.WriteLine($"缓存超时: {timeout}分钟");
```

### 2.3 修改和保存配置

修改配置属性后，调用 `Save()` 方法保存配置：

```csharp
// 获取配置实例
var config = AppConfig.Current;

// 修改配置
config.ApplicationName = "新应用名称";
config.DebugMode = true;
config.CacheTimeoutMinutes = 15;

// 保存配置（不会触发自动重新加载事件）
config.Save();
Console.WriteLine("配置已保存");
```

### 2.4 设置配置变更事件处理（推荐方式）

使用统一的配置变更事件管理机制：

```csharp
// 在应用程序启动时设置配置变更事件处理
public static void SetupConfigurationEvents()
{
    // 订阅应用配置变更
    ConfigManager.SubscribeConfigChanged<AppConfig>(newConfig =>
    {
        Console.WriteLine($"应用配置已更新: {newConfig.ApplicationName}");
        // 在这里处理配置变更后的业务逻辑
        // 例如：重新初始化服务、更新缓存等
    });

    // 订阅配置变更并比较新旧值
    ConfigManager.SubscribeConfigChanged<AppConfig>((oldConfig, newConfig) =>
    {
        if (oldConfig.DebugMode != newConfig.DebugMode)
        {
            Console.WriteLine($"调试模式变更: {oldConfig.DebugMode} → {newConfig.DebugMode}");
            // 根据调试模式变更更新日志级别
            LogManager.UpdateDebugMode(newConfig.DebugMode);
        }
    });

    // 监控所有配置变更
    ConfigManager.SubscribeAllConfigChanged(e =>
    {
        Console.WriteLine($"配置 {e.ConfigName} 在 {DateTime.Now:HH:mm:ss} 发生变更");
        // 记录配置变更审计日志
        AuditLogger.LogConfigurationChange(e);
    });
}
```

### 2.5 手动修改配置文件测试

现在您可以直接修改配置文件来测试自动重新加载功能：

1. 找到配置文件（例如：`应用程序目录/Config/AppConfig.config`）
2. 用文本编辑器打开配置文件
3. 修改其中的值
4. 保存文件
5. 观察应用程序自动检测变更并更新内存对象

## 3. 高级用法

### 3.1 通用配置变更事件管理

#### 3.1.1 订阅特定类型的配置变更

```csharp
// 简单订阅：只接收新配置值
ConfigManager.SubscribeConfigChanged<DatabaseConfig>(newConfig =>
{
    // 重新配置数据库连接
    DatabaseManager.UpdateConnectionString(newConfig.ConnectionString);
});

// 完整订阅：接收新旧配置值进行对比
ConfigManager.SubscribeConfigChanged<ApiConfig>((oldConfig, newConfig) =>
{
    // 只在API地址变更时处理
    if (oldConfig.BaseUrl != newConfig.BaseUrl)
    {
        HttpClientManager.UpdateBaseUrl(newConfig.BaseUrl);
    }
    
    // 只在超时设置变更时处理
    if (oldConfig.TimeoutSeconds != newConfig.TimeoutSeconds)
    {
        HttpClientManager.UpdateTimeout(TimeSpan.FromSeconds(newConfig.TimeoutSeconds));
    }
});
```

#### 3.1.2 订阅所有配置类型的变更

```csharp
ConfigManager.SubscribeAllConfigChanged(e =>
{
    // 记录配置变更日志
    Logger.LogInformation($"Configuration {e.ConfigName} updated at {DateTime.Now}");
    
    // 发送变更通知
    NotificationService.SendConfigChangeAlert(e.ConfigName);
    
    // 更新监控指标
    Metrics.Counter("config_changes").WithTag("config_type", e.ConfigName).Increment();
});
```

#### 3.1.3 统一配置事件管理模式

```csharp
public class ConfigurationEventManager
{
    public static void Initialize()
    {
        // 应用配置变更处理
        ConfigManager.SubscribeConfigChanged<AppConfig>(config =>
        {
            UpdateApplicationSettings(config);
        });

        // 数据库配置变更处理
        ConfigManager.SubscribeConfigChanged<DatabaseConfig>(config =>
        {
            ReconfigureDatabaseConnections(config);
        });

        // 缓存配置变更处理
        ConfigManager.SubscribeConfigChanged<CacheConfig>(config =>
        {
            ReconfigureCacheSettings(config);
        });

        // API配置变更处理
        ConfigManager.SubscribeConfigChanged<ApiConfig>((oldConfig, newConfig) =>
        {
            if (oldConfig.BaseUrl != newConfig.BaseUrl)
            {
                ReinitializeHttpClients(newConfig);
            }
        });

        // 全局配置变更监控
        ConfigManager.SubscribeAllConfigChanged(e =>
        {
            AuditConfigurationChange(e);
            NotifyAdministrators(e);
        });
    }

    private static void UpdateApplicationSettings(AppConfig config)
    {
        // 更新应用程序设置的具体逻辑
    }

    private static void ReconfigureDatabaseConnections(DatabaseConfig config)
    {
        // 重新配置数据库连接的具体逻辑
    }

    // 其他方法...
}
```

### 3.2 智能自动重新加载控制

#### 3.2.1 全局控制自动重新加载

```csharp
// 在应用程序启动时控制自动重新加载
public static void ConfigureAutoReload()
{
    // 默认情况下自动重新加载是启用的
    // 如果需要禁用，可以调用：
    // ConfigManager.SetAutoReload(false);
    
    // 在开发环境启用，生产环境可能需要禁用
    bool isProduction = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Production";
    if (isProduction)
    {
        // 在生产环境中禁用自动重新加载
        ConfigManager.SetAutoReload(false);
        Console.WriteLine("生产环境：已禁用配置自动重新加载");
    }
    else
    {
        Console.WriteLine("开发环境：已启用配置自动重新加载");
    }
}
```

#### 3.2.2 智能过滤机制说明

配置系统具有智能过滤机制，能够区分代码保存和外部修改：

```csharp
// 代码保存 - 不会触发自动重新加载事件
var config = AppConfig.Current;
config.ApplicationName = "通过代码修改";
config.Save(); // 这不会触发配置变更事件

// 外部修改 - 会触发自动重新加载事件
// 手动修改 Config/AppConfig.config 文件并保存
// 系统会自动检测并触发配置变更事件
```

### 3.3 AOT 兼容性配置

在 AOT 环境中的完整配置模式：

```csharp
// 1. 创建JsonSerializerContext
[JsonSerializable(typeof(AppConfig))]
[JsonSerializable(typeof(DatabaseConfig))]
[JsonSerializable(typeof(ApiConfig))]
public partial class AppConfigsJsonContext : JsonSerializerContext
{
}

// 2. 配置类定义
public class AppConfig : Config<AppConfig>
{
    public string ApplicationName { get; set; } = "我的应用";
    public bool DebugMode { get; set; } = false;

    static AppConfig()
    {
        RegisterConfigForAot(AppConfigsJsonContext.Default);
    }
}

// 3. 在程序启动时初始化
public static void Main(string[] args)
{
    try
    {
        // 设置配置事件处理
        ConfigurationEventManager.Initialize();
        
        // 触发配置初始化
        var appConfig = AppConfig.Current;
        var dbConfig = DatabaseConfig.Current;
        
        Console.WriteLine("配置系统初始化成功");
        
        // 应用程序逻辑...
    }
    catch (Exception ex)
    {
        Console.WriteLine($"配置初始化失败: {ex.Message}");
    }
}
```

### 3.4 复杂配置管理

#### 3.4.1 多层级配置结构

```csharp
// 嵌套配置类
public class ServerSettings
{
    public string Host { get; set; } = "localhost";
    public int Port { get; set; } = 8080;
    public bool UseHttps { get; set; } = false;
}

public class DatabaseSettings
{
    public string ConnectionString { get; set; } = "Server=localhost;Database=MyApp;";
    public int MaxConnections { get; set; } = 100;
    public int CommandTimeoutSeconds { get; set; } = 30;
}

[JsonSerializable(typeof(ApplicationConfig))]
[JsonSerializable(typeof(ServerSettings))]
[JsonSerializable(typeof(DatabaseSettings))]
public partial class ApplicationConfigJsonContext : JsonSerializerContext
{
}

public class ApplicationConfig : Config<ApplicationConfig>
{
    public string Name { get; set; } = "我的应用";
    public ServerSettings Server { get; set; } = new ServerSettings();
    public DatabaseSettings Database { get; set; } = new DatabaseSettings();
    public List<string> EnabledFeatures { get; set; } = new List<string> { "Logging", "Metrics" };

    static ApplicationConfig()
    {
        RegisterConfigForAot(ApplicationConfigJsonContext.Default);
    }
}
```

#### 3.4.2 配置验证和错误处理

```csharp
public class ValidatedConfig : Config<ValidatedConfig>
{
    private string _apiUrl = "https://api.example.com";
    
    public string ApiUrl 
    { 
        get => _apiUrl;
        set
        {
            if (string.IsNullOrEmpty(value))
                throw new ArgumentException("API URL 不能为空");
            
            if (!Uri.TryCreate(value, UriKind.Absolute, out _))
                throw new ArgumentException("API URL 格式无效");
                
            _apiUrl = value;
        }
    }

    public int MaxRetries { get; set; } = 3;

    // 重写Save方法添加额外验证
    public override void Save()
    {
        Validate();
        base.Save();
    }

    private void Validate()
    {
        if (MaxRetries < 0 || MaxRetries > 10)
            throw new ArgumentOutOfRangeException(nameof(MaxRetries), "重试次数必须在0-10之间");
    }

    static ValidatedConfig()
    {
        RegisterConfigForAot(ValidatedConfigJsonContext.Default);
    }
}

[JsonSerializable(typeof(ValidatedConfig))]
public partial class ValidatedConfigJsonContext : JsonSerializerContext
{
}
```

### 3.5 配置变更事件的高级应用

#### 3.5.1 条件性配置更新

```csharp
ConfigManager.SubscribeConfigChanged<ApiConfig>((oldConfig, newConfig) =>
{
    // 只在重要配置变更时处理
    bool needsReinitialization = 
        oldConfig.BaseUrl != newConfig.BaseUrl ||
        oldConfig.ApiKey != newConfig.ApiKey ||
        oldConfig.TimeoutSeconds != newConfig.TimeoutSeconds;

    if (needsReinitialization)
    {
        Console.WriteLine("检测到重要配置变更，正在重新初始化API客户端...");
        ApiClientManager.Reinitialize(newConfig);
    }
    else
    {
        Console.WriteLine("检测到次要配置变更，无需重新初始化");
    }
});
```

#### 3.5.2 配置变更的级联处理

```csharp
public class CascadingConfigHandler
{
    public static void Initialize()
    {
        // 数据库配置变更可能影响缓存配置
        ConfigManager.SubscribeConfigChanged<DatabaseConfig>(dbConfig =>
        {
            // 重新配置数据库连接
            DatabaseManager.Reconfigure(dbConfig);
            
            // 清除相关缓存
            CacheManager.ClearDatabaseRelatedCache();
            
            // 通知其他依赖组件
            EventBus.Publish(new DatabaseConfigChangedEvent(dbConfig));
        });

        // API配置变更可能影响多个服务
        ConfigManager.SubscribeConfigChanged<ApiConfig>(apiConfig =>
        {
            // 更新HTTP客户端
            HttpClientFactory.UpdateConfiguration(apiConfig);
            
            // 更新API文档生成器
            SwaggerGenerator.UpdateApiInfo(apiConfig);
            
            // 更新监控配置
            HealthCheckManager.UpdateApiEndpoints(apiConfig);
        });
    }
}
```

#### 3.5.3 异步配置处理

```csharp
ConfigManager.SubscribeConfigChanged<HeavyConfig>(async newConfig =>
{
    try
    {
        Console.WriteLine("开始处理重型配置变更...");
        
        // 异步处理耗时的配置更新
        await Task.Run(async () =>
        {
            await HeavyService.ReconfigureAsync(newConfig);
            await CacheService.WarmupAsync(newConfig);
            await NotificationService.SendConfigUpdateNotificationAsync(newConfig);
        });
        
        Console.WriteLine("重型配置变更处理完成");
    }
    catch (Exception ex)
    {
        Logger.LogError(ex, "处理重型配置变更时发生错误");
    }
});
```

## 4. 配置文件管理

### 4.1 配置文件位置和格式

配置文件默认保存在应用程序根目录下的 `Config` 文件夹中：

```
应用程序根目录/
├── Config/
│   ├── AppConfig.config
│   ├── DatabaseConfig.config
│   └── ApiConfig.config
└── 其他文件...
```

### 4.2 智能自动重新加载机制

系统会自动监控配置文件的变更：

- **外部修改检测**：当您用文本编辑器修改配置文件时，系统会自动检测并重新加载
- **代码保存过滤**：当通过 `config.Save()` 保存时，不会触发重新加载事件
- **防抖处理**：短时间内的多次文件变更只会触发一次重新加载
- **异步处理**：文件变更检测和配置重新加载都是异步进行的

### 4.3 手动修改配置文件的最佳实践

1. **确保JSON格式正确**：使用支持JSON语法检查的编辑器
2. **保存后观察日志**：查看应用程序输出，确认配置已自动重新加载
3. **测试关键功能**：验证配置变更是否正确应用到应用程序中
4. **备份重要配置**：在修改前备份配置文件

## 5. 最佳实践

### 5.1 应用程序启动时的配置初始化

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 1. 首先设置配置变更事件处理
        ConfigurationEventManager.Initialize();
        
        // 2. 初始化配置（触发自动初始化和文件监控）
        var appConfig = AppConfig.Current;
        var dbConfig = DatabaseConfig.Current;
        var apiConfig = ApiConfig.Current;
        
        // 3. 基于配置注册服务
        services.Configure<DbContextOptions>(options =>
        {
            options.UseSqlServer(dbConfig.ConnectionString);
        });
        
        services.AddHttpClient("api", client =>
        {
            client.BaseAddress = new Uri(apiConfig.BaseUrl);
            client.Timeout = TimeSpan.FromSeconds(apiConfig.TimeoutSeconds);
        });
    }
}
```

### 5.2 配置变更事件处理的最佳实践

```csharp
public static class ConfigEventBestPractices
{
    public static void SetupEvents()
    {
        // 1. 使用具体的配置变更处理，避免在事件中执行耗时操作
        ConfigManager.SubscribeConfigChanged<DatabaseConfig>(config =>
        {
            // 快速的配置更新
            DatabaseConnectionManager.UpdateConnectionString(config.ConnectionString);
        });

        // 2. 对于耗时操作，使用异步处理
        ConfigManager.SubscribeConfigChanged<HeavyConfig>(async config =>
        {
            await Task.Run(() => HeavyService.Reconfigure(config));
        });

        // 3. 添加异常处理
        ConfigManager.SubscribeConfigChanged<CriticalConfig>(config =>
        {
            try
            {
                CriticalService.Update(config);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "更新关键配置时发生错误");
                // 可能需要回滚或使用默认配置
            }
        });

        // 4. 记录配置变更审计日志
        ConfigManager.SubscribeAllConfigChanged(e =>
        {
            AuditLogger.Log($"Configuration {e.ConfigName} changed", new
            {
                ConfigType = e.ConfigType.Name,
                Timestamp = DateTime.UtcNow,
                OldValue = JsonSerializer.Serialize(e.OldConfig),
                NewValue = JsonSerializer.Serialize(e.NewConfig)
            });
        });
    }
}
```

### 5.3 AOT环境下的配置管理

在AOT编译环境中，需要特别注意配置的初始化方式：

```csharp
public class AotConfigManager
{
    public static void Initialize()
    {
        // 1. 确保所有JsonSerializerContext都已正确定义
        var appOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = AppConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        var dbOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = DatabaseConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        // 2. 手动注册所有配置类型
        ConfigManager.RegisterConfig<AppConfig>(appOptions);
        ConfigManager.RegisterConfig<DatabaseConfig>(dbOptions);

        // 3. 预热所有配置实例
        var appConfig = AppConfig.Current;
        var dbConfig = DatabaseConfig.Current;

        Console.WriteLine("AOT配置初始化完成");
    }
}
```

### 5.4 配置的运行时验证

```csharp
public class ValidatedApiConfig : Config<ValidatedApiConfig>
{
    private string _baseUrl = "https://api.example.com";
    private int _timeoutSeconds = 30;

    public string BaseUrl
    {
        get => _baseUrl;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("API基础URL不能为空");
            
            if (!Uri.TryCreate(value, UriKind.Absolute, out var uri))
                throw new ArgumentException("API基础URL格式不正确");
            
            _baseUrl = value;
        }
    }

    public int TimeoutSeconds
    {
        get => _timeoutSeconds;
        set
        {
            if (value <= 0 || value > 300)
                throw new ArgumentOutOfRangeException(nameof(TimeoutSeconds), "超时时间必须在1-300秒之间");
            
            _timeoutSeconds = value;
        }
    }

    public string ApiKey { get; set; } = "";

    static ValidatedApiConfig()
    {
        RegisterConfigForAot(ValidatedApiConfigJsonContext.Default);
    }

    public override void Save()
    {
        // 保存前进行最终验证
        ValidateConfiguration();
        base.Save();
    }

    private void ValidateConfiguration()
    {
        if (string.IsNullOrWhiteSpace(ApiKey))
            throw new InvalidOperationException("API密钥不能为空");
    }
}

[JsonSerializable(typeof(ValidatedApiConfig))]
public partial class ValidatedApiConfigJsonContext : JsonSerializerContext
{
}
```

## 6. 常见问题解答

### 6.1 配置文件不存在时会发生什么？

当配置文件不存在时，系统会：
1. 创建一个新的配置实例，使用默认值
2. 自动创建 `Config` 目录（如果不存在）
3. 在首次调用 `Save()` 时创建配置文件
4. 启动文件监控功能

### 6.2 如何处理配置文件格式错误？

```csharp
try
{
    var config = AppConfig.Current;
}
catch (JsonException ex)
{
    Logger.LogError(ex, "配置文件格式错误");
    
    // 选择1：使用默认配置
    var defaultConfig = new AppConfig();
    
    // 选择2：备份损坏的文件并重新创建
    var corruptedFile = "Config/AppConfig.config";
    var backupFile = $"Config/AppConfig.config.backup.{DateTime.Now:yyyyMMddHHmmss}";
    File.Move(corruptedFile, backupFile);
    
    var newConfig = new AppConfig();
    newConfig.Save();
}
```

### 6.3 自动重新加载功能什么时候会触发？

自动重新加载功能在以下情况下**会**触发：
- 手动编辑配置文件并保存
- 外部程序修改配置文件
- 通过文件管理器复制/替换配置文件

在以下情况下**不会**触发：
- 通过 `config.Save()` 保存配置
- 代码保存后1000毫秒内的文件变更
- 防抖间隔（500毫秒）内的重复变更

### 6.4 如何在不同部署环境中管理配置？

虽然配置系统不内置多环境支持，但您可以通过以下方式管理不同环境的配置：

```csharp
public class DeploymentConfig : Config<DeploymentConfig>
{
    public string ApiUrl { get; set; } = "https://localhost:5000";
    public string DatabaseConnection { get; set; } = "Server=localhost;Database=Dev;";
    public bool EnableDebugLogging { get; set; } = true;
    public string LogLevel { get; set; } = "Debug";

    static DeploymentConfig()
    {
        RegisterConfigForAot(DeploymentConfigJsonContext.Default);
        
        // 根据环境变量调整配置
        var config = Current;
        config.AdjustForCurrentEnvironment();
        config.Save();
    }

    public void AdjustForCurrentEnvironment()
    {
        var environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Development";
        
        switch (environment.ToLower())
        {
            case "production":
                ApiUrl = Environment.GetEnvironmentVariable("PROD_API_URL") ?? "https://api.production.com";
                DatabaseConnection = Environment.GetEnvironmentVariable("PROD_DB_CONNECTION") ?? DatabaseConnection;
                EnableDebugLogging = false;
                LogLevel = "Information";
                break;
                
            case "staging":
                ApiUrl = Environment.GetEnvironmentVariable("STAGING_API_URL") ?? "https://api.staging.com";
                DatabaseConnection = Environment.GetEnvironmentVariable("STAGING_DB_CONNECTION") ?? DatabaseConnection;
                EnableDebugLogging = false;
                LogLevel = "Warning";
                break;
                
            default: // Development
                // 使用默认的开发环境设置
                break;
        }
    }
}

[JsonSerializable(typeof(DeploymentConfig))]
public partial class DeploymentConfigJsonContext : JsonSerializerContext
{
}
```

### 6.5 如何处理配置变更的错误？

```csharp
ConfigManager.SubscribeConfigChanged<DatabaseConfig>(config =>
{
    try
    {
        // 测试新的数据库连接
        using var connection = new SqlConnection(config.ConnectionString);
        connection.Open();
        
        // 连接成功，应用新配置
        DatabaseManager.UpdateConnectionString(config.ConnectionString);
        Logger.LogInformation("数据库配置更新成功");
    }
    catch (Exception ex)
    {
        Logger.LogError(ex, "新的数据库配置无效，保持使用原配置");
        
        // 可选：发送告警通知管理员
        AlertManager.SendConfigErrorAlert("DatabaseConfig", ex.Message);
    }
});
```

## 7. 完整示例

### 7.1 基本配置示例

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp
{
    [JsonSerializable(typeof(AppSettings))]
    public partial class AppSettingsJsonContext : JsonSerializerContext
    {
    }

    public class AppSettings : Config<AppSettings>
    {
        public string Title { get; set; } = "我的应用";
        public string Theme { get; set; } = "Light";
        public bool NotificationsEnabled { get; set; } = true;
        public int RefreshIntervalSeconds { get; set; } = 60;

        static AppSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppSettings>(options);
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 获取配置
                var settings = AppSettings.Current;
                Console.WriteLine($"标题: {settings.Title}");
                Console.WriteLine($"主题: {settings.Theme}");
                Console.WriteLine($"通知: {(settings.NotificationsEnabled ? "已启用" : "已禁用")}");
                Console.WriteLine($"刷新间隔: {settings.RefreshIntervalSeconds}秒");

                // 修改配置
                Console.WriteLine("\n修改配置...");
                settings.Title = "我的新应用";
                settings.Theme = "Dark";
                settings.Save();
                Console.WriteLine("配置已保存\n");

                // 重新加载配置
                AppSettings.Reload();
                var reloadedSettings = AppSettings.Current;
                Console.WriteLine("重新加载配置:");
                Console.WriteLine($"标题: {reloadedSettings.Title}");
                Console.WriteLine($"主题: {reloadedSettings.Theme}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"错误: {ex.Message}");
            }
        }
    }
}
```

### 7.2 多配置类示例

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp
{
    // 应用设置配置
    [JsonSerializable(typeof(AppSettings))]
    public partial class AppSettingsJsonContext : JsonSerializerContext
    {
    }

    public class AppSettings : Config<AppSettings>
    {
        public string Title { get; set; } = "我的应用";
        public string Theme { get; set; } = "Light";

        static AppSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppSettings>(options);
        }
    }

    // 用户设置配置
    [JsonSerializable(typeof(UserSettings))]
    public partial class UserSettingsJsonContext : JsonSerializerContext
    {
    }

    public class UserSettings : Config<UserSettings>
    {
        public string Username { get; set; } = "默认用户";
        public bool RememberLogin { get; set; } = false;
        public string Language { get; set; } = "zh-CN";

        static UserSettings()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = UserSettingsJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<UserSettings>(options);
        }
    }

    // 使用多配置类
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 获取应用设置
                var appSettings = AppSettings.Current;
                Console.WriteLine($"应用标题: {appSettings.Title}");
                Console.WriteLine($"应用主题: {appSettings.Theme}");

                // 获取用户设置
                var userSettings = UserSettings.Current;
                Console.WriteLine($"用户名: {userSettings.Username}");
                Console.WriteLine($"记住登录: {userSettings.RememberLogin}");
                Console.WriteLine($"语言: {userSettings.Language}");

                // 修改设置
                appSettings.Theme = "Dark";
                appSettings.Save();

                userSettings.Username = "新用户";
                userSettings.Language = "en-US";
                userSettings.Save();

                Console.WriteLine("\n设置已保存");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"错误: {ex.Message}");
            }
        }
    }
}
```

### 7.3 带配置变更处理的完整应用

```csharp
using System;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace ConfigurationDemo
{
    // 配置类定义
    [JsonSerializable(typeof(AppSettings))]
    public partial class AppSettingsJsonContext : JsonSerializerContext { }

    public class AppSettings : Config<AppSettings>
    {
        public string Title { get; set; } = "演示应用";
        public string ApiUrl { get; set; } = "https://api.demo.com";
        public int RefreshInterval { get; set; } = 60;
        public bool EnableLogging { get; set; } = true;

        static AppSettings()
        {
            RegisterConfigForAot(AppSettingsJsonContext.Default);
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("=== 配置系统演示 ===");
            
            // 设置配置变更事件
            SetupConfigurationEvents();
            
            // 获取初始配置
            var settings = AppSettings.Current;
            Console.WriteLine($"初始配置 - 标题: {settings.Title}, API: {settings.ApiUrl}");
            
            Console.WriteLine("\n你可以尝试以下操作：");
            Console.WriteLine("1. 修改配置文件: Config/AppSettings.config");
            Console.WriteLine("2. 按 's' 通过代码保存配置");
            Console.WriteLine("3. 按 'q' 退出");
            Console.WriteLine("\n观察配置变更事件的触发...\n");
            
            // 主循环
            while (true)
            {
                var key = Console.ReadKey(true);
                if (key.KeyChar == 'q') break;
                
                if (key.KeyChar == 's')
                {
                    // 通过代码修改并保存配置
                    var config = AppSettings.Current;
                    config.Title = $"代码更新 - {DateTime.Now:HH:mm:ss}";
                    config.Save();
                    Console.WriteLine($"通过代码保存配置: {config.Title}");
                }
            }
        }

        private static void SetupConfigurationEvents()
        {
            // 订阅配置变更（新旧值比较）
            ConfigManager.SubscribeConfigChanged<AppSettings>((oldConfig, newConfig) =>
            {
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] 配置已变更:");
                
                if (oldConfig.Title != newConfig.Title)
                    Console.WriteLine($"  标题: {oldConfig.Title} → {newConfig.Title}");
                    
                if (oldConfig.ApiUrl != newConfig.ApiUrl)
                    Console.WriteLine($"  API地址: {oldConfig.ApiUrl} → {newConfig.ApiUrl}");
                    
                if (oldConfig.RefreshInterval != newConfig.RefreshInterval)
                    Console.WriteLine($"  刷新间隔: {oldConfig.RefreshInterval} → {newConfig.RefreshInterval}");
                    
                Console.WriteLine();
            });

            // 全局配置变更监控
            ConfigManager.SubscribeAllConfigChanged(e =>
            {
                Console.WriteLine($"[系统] 配置 {e.ConfigName} 已更新");
            });
        }
    }
}
```

运行这个示例后，你可以：
1. 手动编辑 `Config/AppSettings.config` 文件并保存，观察自动重新加载
2. 按 's' 键通过代码保存配置，注意不会触发变更事件
3. 对比两种方式的不同行为

## 8. 总结

Pek.Common 配置系统提供了完整的配置管理解决方案，包括：

- **智能自动重新加载**：区分代码保存和外部修改，只在需要时触发重新加载
- **通用事件管理**：统一的配置变更事件订阅机制，支持多种订阅方式
- **类型安全访问**：强类型配置类，编译时检查，运行时安全
- **AOT 兼容性**：完全支持AOT编译环境
- **高性能**：懒加载、缓存机制、防抖处理

通过遵循本指南中的最佳实践，您可以构建一个健壮、高效、易维护的配置管理系统。