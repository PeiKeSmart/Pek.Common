# Pek.Common 配置系统单元测试指南

## 1. 简介

本文档提供了对 Pek.Common 配置系统进行单元测试的指南和最佳实践。通过全面的测试，可以确保配置系统在各种情况下都能正常工作，包括配置的保存、加载、重新加载、验证等功能。

### 1.1 测试目标

配置系统的单元测试应该覆盖以下方面：

- 配置注册和初始化
- 配置保存和加载
- 配置重新加载
- 配置文件路径
- 配置持久化
- 配置默认值
- 配置性能
- 配置目录结构
- 异常处理
- AOT 兼容性

## 2. 测试环境设置

### 2.1 测试框架

推荐使用 NUnit、MSTest 或 xUnit 作为测试框架。以下示例使用 NUnit：

```csharp
using NUnit.Framework;
using System;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;
```

### 2.2 测试配置类

为测试创建专门的配置类：

```csharp
[JsonSerializable(typeof(TestConfig))]
public partial class TestConfigJsonContext : JsonSerializerContext
{
}

public class TestConfig : Config<TestConfig>
{
    public string Name { get; set; } = "TestConfig";
    public int Version { get; set; } = 1;
    public bool IsEnabled { get; set; } = true;
    public double Value { get; set; } = 3.14;

    static TestConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = TestConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<TestConfig>(options);
    }
}
```

### 2.3 测试辅助方法

创建辅助方法来管理测试数据：

```csharp
private string GetConfigFilePath()
{
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    return Path.Combine(baseDir, "Config", "TestConfig.config");
}

private void CleanupTestData()
{
    string configFilePath = GetConfigFilePath();
    if (File.Exists(configFilePath))
    {
        File.Delete(configFilePath);
    }
}
```

## 3. 基本测试用例

### 3.1 配置注册测试

测试配置是否正确注册：

```csharp
[Test]
public void TestConfigRegistration()
{
    // 清理测试数据
    CleanupTestData();

    // 验证配置已注册
    var config = TestConfig.Current;
    Assert.IsNotNull(config, "配置实例不应为空");
    Assert.AreEqual("TestConfig", config.Name, "配置名称应为默认值");
    Assert.AreEqual(1, config.Version, "配置版本应为默认值");
    Assert.IsTrue(config.IsEnabled, "配置启用状态应为默认值");
    Assert.AreEqual(3.14, config.Value, 0.001, "配置数值应为默认值");
}
```

### 3.2 配置保存测试

测试配置保存功能：

```csharp
[Test]
public void TestConfigSave()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例
    var config = TestConfig.Current;

    // 修改配置
    config.Name = "Modified";
    config.Version = 2;
    config.IsEnabled = false;
    config.Value = 2.71;

    // 保存配置
    config.Save();

    // 验证配置文件是否创建
    string configFilePath = GetConfigFilePath();
    Assert.IsTrue(File.Exists(configFilePath), "配置文件应该被创建");

    // 验证文件内容
    string fileContent = File.ReadAllText(configFilePath);
    Assert.IsTrue(fileContent.Contains("Modified"), "配置文件应包含修改后的名称");
    Assert.IsTrue(fileContent.Contains("2"), "配置文件应包含修改后的版本");
    Assert.IsTrue(fileContent.Contains("false"), "配置文件应包含修改后的启用状态");
    Assert.IsTrue(fileContent.Contains("2.71"), "配置文件应包含修改后的数值");
}
```

### 3.3 配置重新加载测试

测试配置重新加载功能：

```csharp
[Test]
public void TestConfigReload()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例并修改
    var config = TestConfig.Current;
    config.Name = "Modified";
    config.Save();

    // 手动修改配置文件
    string configFilePath = GetConfigFilePath();
    string json = File.ReadAllText(configFilePath);
    json = json.Replace("Modified", "ManuallyModified");
    File.WriteAllText(configFilePath, json);

    // 重新加载配置
    TestConfig.Reload();
    var reloadedConfig = TestConfig.Current;

    // 验证重新加载的配置
    Assert.AreEqual("ManuallyModified", reloadedConfig.Name, "重新加载后的配置应反映文件中的更改");
}
```

### 3.4 配置文件路径测试

测试配置文件路径：

```csharp
[Test]
public void TestConfigFilePath()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例并保存
    var config = TestConfig.Current;
    config.Save();

    // 验证配置文件路径
    string expectedPath = GetConfigFilePath();
    Assert.IsTrue(File.Exists(expectedPath), "配置文件应该在预期路径");
}
```

## 4. 高级测试用例

### 4.1 配置持久化测试

测试配置的持久化：

```csharp
[Test]
public void TestConfigPersistence()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例并修改
    var config = TestConfig.Current;
    config.Name = "PersistenceTest";
    config.Version = 3;
    config.IsEnabled = false;
    config.Value = 1.23;

    // 保存配置
    config.Save();

    // 重新加载配置
    TestConfig.Reload();
    var reloadedConfig = TestConfig.Current;

    // 验证持久化的配置
    Assert.AreEqual("PersistenceTest", reloadedConfig.Name, "持久化后的名称应保持不变");
    Assert.AreEqual(3, reloadedConfig.Version, "持久化后的版本应保持不变");
    Assert.IsFalse(reloadedConfig.IsEnabled, "持久化后的启用状态应保持不变");
    Assert.AreEqual(1.23, reloadedConfig.Value, 0.001, "持久化后的数值应保持不变");
}
```

### 4.2 配置默认值测试

测试配置默认值：

```csharp
[Test]
public void TestConfigDefaults()
{
    // 清理测试数据
    CleanupTestData();

    // 获取新的配置实例
    var config = TestConfig.Current;

    // 验证默认值
    Assert.AreEqual("TestConfig", config.Name, "配置名称应为默认值");
    Assert.AreEqual(1, config.Version, "配置版本应为默认值");
    Assert.IsTrue(config.IsEnabled, "配置启用状态应为默认值");
    Assert.AreEqual(3.14, config.Value, 0.001, "配置数值应为默认值");
}
```

### 4.3 配置性能测试

测试配置访问和保存的性能：

```csharp
[Test]
public void TestPerformance()
{
    // 清理测试数据
    CleanupTestData();

    // 测试配置访问性能
    var stopwatch = new System.Diagnostics.Stopwatch();
    stopwatch.Start();

    for (int i = 0; i < 1000; i++)
    {
        var config = TestConfig.Current;
        string name = config.Name;
        int version = config.Version;
        bool isEnabled = config.IsEnabled;
        double value = config.Value;
    }

    stopwatch.Stop();
    Console.WriteLine($"1000次配置访问耗时: {stopwatch.ElapsedMilliseconds}ms");
    Assert.Less(stopwatch.ElapsedMilliseconds, 1000, "1000次配置访问应在1秒内完成");

    // 测试配置保存性能
    var config = TestConfig.Current;
    stopwatch.Restart();

    for (int i = 0; i < 10; i++)
    {
        config.Version = i;
        config.Save();
    }

    stopwatch.Stop();
    Console.WriteLine($"10次配置保存耗时: {stopwatch.ElapsedMilliseconds}ms");
    Assert.Less(stopwatch.ElapsedMilliseconds, 1000, "10次配置保存应在1秒内完成");
}
```

### 4.4 配置目录结构测试

测试配置目录结构：

```csharp
[Test]
public void TestConfigDirectoryStructure()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例并保存
    var config = TestConfig.Current;
    config.Save();

    // 验证配置目录结构
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    string configDir = Path.Combine(baseDir, "Config");
    Assert.IsTrue(Directory.Exists(configDir), "Config目录应该存在");

    string configFilePath = Path.Combine(configDir, "TestConfig.config");
    Assert.IsTrue(File.Exists(configFilePath), "配置文件应该存在");
}
```

### 4.5 异常处理测试

测试配置系统的异常处理：

```csharp
[Test]
public void TestExceptionHandling()
{
    // 清理测试数据
    CleanupTestData();

    // 获取配置实例并保存
    var config = TestConfig.Current;
    config.Save();

    // 获取配置文件路径
    string configFilePath = GetConfigFilePath();

    // 写入无效的JSON
    File.WriteAllText(configFilePath, "{ invalid json }");

    // 验证重新加载时的异常处理
    Assert.DoesNotThrow(() =>
    {
        TestConfig.Reload();
        var reloadedConfig = TestConfig.Current;

        // 应该使用默认值
        Assert.AreEqual("TestConfig", reloadedConfig.Name, "加载失败时应使用默认值");
    }, "配置系统应该优雅地处理无效的JSON");
}
```

### 4.6 自定义文件名测试

测试自定义配置文件名：

```csharp
[JsonSerializable(typeof(CustomNameConfig))]
public partial class CustomNameConfigJsonContext : JsonSerializerContext
{
}

public class CustomNameConfig : Config<CustomNameConfig>
{
    public string Setting { get; set; } = "Default";

    static CustomNameConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = CustomNameConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        // 使用自定义文件名
        ConfigManager.RegisterConfig<CustomNameConfig>(options, "custom.settings");
    }
}

[Test]
public void TestCustomFileName()
{
    // 清理测试数据
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    string customFilePath = Path.Combine(baseDir, "Config", "custom.settings");
    if (File.Exists(customFilePath))
    {
        File.Delete(customFilePath);
    }

    // 获取配置实例并保存
    var config = CustomNameConfig.Current;
    config.Setting = "CustomValue";
    config.Save();

    // 验证自定义文件名
    Assert.IsTrue(File.Exists(customFilePath), "应使用自定义文件名");

    // 验证文件内容
    string fileContent = File.ReadAllText(customFilePath);
    Assert.IsTrue(fileContent.Contains("CustomValue"), "配置文件应包含设置值");
}
```

## 5. AOT 兼容性测试

### 5.1 模拟 AOT 环境测试

测试在模拟的 AOT 环境中的配置系统：

```csharp
[Test]
public void TestAotCompatibility()
{
    // 清理测试数据
    CleanupTestData();

    // 模拟 AOT 环境下的配置初始化
    try
    {
        // 手动注册配置
        var jsonOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = TestConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<TestConfig>(jsonOptions);

        // 触发初始化
        var config = TestConfig.Current;
        config.Name = "AotTest";
        config.Save();

        // 重新加载配置
        TestConfig.Reload();
        var reloadedConfig = TestConfig.Current;

        // 验证配置
        Assert.AreEqual("AotTest", reloadedConfig.Name, "AOT环境下配置应正常工作");
    }
    catch (Exception ex)
    {
        Assert.Fail($"AOT兼容性测试失败: {ex.Message}");
    }
}
```

### 5.2 复杂类型 AOT 测试

测试在 AOT 环境中使用复杂类型：

```csharp
public class NestedObject
{
    public string Property { get; set; } = "Nested";
    public int Value { get; set; } = 42;
}

[JsonSerializable(typeof(ComplexTypeConfig))]
[JsonSerializable(typeof(NestedObject))]
[JsonSerializable(typeof(List<string>))]
[JsonSerializable(typeof(Dictionary<string, int>))]
public partial class ComplexTypeConfigJsonContext : JsonSerializerContext
{
}

public class ComplexTypeConfig : Config<ComplexTypeConfig>
{
    public List<string> StringList { get; set; } = new List<string> { "Item1", "Item2" };
    public Dictionary<string, int> Dictionary { get; set; } = new Dictionary<string, int> { { "Key1", 1 }, { "Key2", 2 } };
    public NestedObject Nested { get; set; } = new NestedObject();

    static ComplexTypeConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ComplexTypeConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ComplexTypeConfig>(options);
    }
}

[Test]
public void TestComplexTypeAotCompatibility()
{
    // 清理测试数据
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    string complexFilePath = Path.Combine(baseDir, "Config", "ComplexTypeConfig.config");
    if (File.Exists(complexFilePath))
    {
        File.Delete(complexFilePath);
    }

    try
    {
        // 模拟 AOT 环境下的配置初始化
        var jsonOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = ComplexTypeConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ComplexTypeConfig>(jsonOptions);

        // 获取配置实例
        var config = ComplexTypeConfig.Current;

        // 修改复杂类型
        config.StringList.Add("Item3");
        config.Dictionary["Key3"] = 3;
        config.Nested.Property = "Modified";
        config.Nested.Value = 100;

        // 保存配置
        config.Save();

        // 重新加载配置
        ComplexTypeConfig.Reload();
        var reloadedConfig = ComplexTypeConfig.Current;

        // 验证复杂类型
        Assert.AreEqual(3, reloadedConfig.StringList.Count, "字符串列表应保持不变");
        Assert.AreEqual("Item3", reloadedConfig.StringList[2], "字符串列表项应保持不变");
        Assert.AreEqual(3, reloadedConfig.Dictionary.Count, "字典应保持不变");
        Assert.AreEqual(3, reloadedConfig.Dictionary["Key3"], "字典项应保持不变");
        Assert.AreEqual("Modified", reloadedConfig.Nested.Property, "嵌套对象属性应保持不变");
        Assert.AreEqual(100, reloadedConfig.Nested.Value, "嵌套对象值应保持不变");
    }
    catch (Exception ex)
    {
        Assert.Fail($"复杂类型AOT兼容性测试失败: {ex.Message}");
    }
}
```

## 6. 集成测试

### 6.1 多配置类集成测试

测试多个配置类的集成：

```csharp
[JsonSerializable(typeof(ConfigA))]
public partial class ConfigAJsonContext : JsonSerializerContext
{
}

[JsonSerializable(typeof(ConfigB))]
public partial class ConfigBJsonContext : JsonSerializerContext
{
}

public class ConfigA : Config<ConfigA>
{
    public string SettingA { get; set; } = "DefaultA";

    static ConfigA()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ConfigAJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ConfigA>(options);
    }
}

public class ConfigB : Config<ConfigB>
{
    public string SettingB { get; set; } = "DefaultB";

    static ConfigB()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ConfigBJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ConfigB>(options);
    }
}

[Test]
public void TestMultipleConfigIntegration()
{
    // 清理测试数据
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    string configAPath = Path.Combine(baseDir, "Config", "ConfigA.config");
    string configBPath = Path.Combine(baseDir, "Config", "ConfigB.config");

    if (File.Exists(configAPath))
    {
        File.Delete(configAPath);
    }

    if (File.Exists(configBPath))
    {
        File.Delete(configBPath);
    }

    // 获取并修改配置A
    var configA = ConfigA.Current;
    configA.SettingA = "ModifiedA";
    configA.Save();

    // 获取并修改配置B
    var configB = ConfigB.Current;
    configB.SettingB = "ModifiedB";
    configB.Save();

    // 验证两个配置文件都存在
    Assert.IsTrue(File.Exists(configAPath), "配置A文件应该存在");
    Assert.IsTrue(File.Exists(configBPath), "配置B文件应该存在");

    // 重新加载两个配置
    ConfigA.Reload();
    ConfigB.Reload();

    // 验证重新加载的配置
    Assert.AreEqual("ModifiedA", ConfigA.Current.SettingA, "配置A应保持不变");
    Assert.AreEqual("ModifiedB", ConfigB.Current.SettingB, "配置B应保持不变");
}
```

### 6.2 配置依赖测试

测试配置之间的依赖关系：

```csharp
[JsonSerializable(typeof(ParentConfig))]
public partial class ParentConfigJsonContext : JsonSerializerContext
{
}

[JsonSerializable(typeof(ChildConfig))]
public partial class ChildConfigJsonContext : JsonSerializerContext
{
}

public class ParentConfig : Config<ParentConfig>
{
    public string BasePath { get; set; } = "C:\\Data";
    public bool EnableLogging { get; set; } = true;

    static ParentConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ParentConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ParentConfig>(options);
    }
}

public class ChildConfig : Config<ChildConfig>
{
    // 依赖于 ParentConfig
    public string GetFullPath()
    {
        var parent = ParentConfig.Current;
        return Path.Combine(parent.BasePath, SubPath);
    }

    public string SubPath { get; set; } = "Logs";

    static ChildConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ChildConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        ConfigManager.RegisterConfig<ChildConfig>(options);
    }
}

[Test]
public void TestConfigDependency()
{
    // 清理测试数据
    string baseDir = AppDomain.CurrentDomain.BaseDirectory;
    string parentPath = Path.Combine(baseDir, "Config", "ParentConfig.config");
    string childPath = Path.Combine(baseDir, "Config", "ChildConfig.config");

    if (File.Exists(parentPath))
    {
        File.Delete(parentPath);
    }

    if (File.Exists(childPath))
    {
        File.Delete(childPath);
    }

    // 修改父配置
    var parent = ParentConfig.Current;
    parent.BasePath = "D:\\AppData";
    parent.Save();

    // 修改子配置
    var child = ChildConfig.Current;
    child.SubPath = "Reports";
    child.Save();

    // 验证依赖关系
    string fullPath = child.GetFullPath();
    Assert.AreEqual("D:\\AppData\\Reports", fullPath, "子配置应正确使用父配置的值");

    // 修改父配置并验证变化
    parent.BasePath = "E:\\Data";
    parent.Save();
    ParentConfig.Reload();

    fullPath = child.GetFullPath();
    Assert.AreEqual("E:\\Data\\Reports", fullPath, "子配置应反映父配置的变化");
}
```

## 7. 测试最佳实践

### 7.1 测试隔离

- 每个测试方法应该独立运行，不依赖于其他测试的状态
- 在每个测试开始时清理测试数据
- 使用专门的测试配置类，避免影响实际应用程序的配置

### 7.2 测试覆盖率

- 确保测试覆盖所有配置系统的功能
- 测试正常情况和异常情况
- 测试边界条件和特殊值

### 7.3 测试性能

- 包含性能测试，确保配置系统在高负载下仍能正常工作
- 设置合理的性能期望值
- 记录性能测试结果，以便进行比较和优化

### 7.4 测试可维护性

- 使用描述性的测试方法名称
- 为测试添加详细的注释和断言消息
- 将通用的测试逻辑提取到辅助方法中

## 8. 常见问题和解决方案

### 8.1 测试失败的常见原因

- 配置文件路径不正确
- 配置文件格式错误
- 配置类型不匹配
- 序列化选项配置错误
- 文件访问权限问题

### 8.2 解决方案

- 使用绝对路径或相对于应用程序目录的路径
- 在测试前清理测试数据
- 确保配置类型和序列化选项正确
- 使用 try-catch 块捕获和处理异常
- 检查文件访问权限

## 9. 总结

全面的单元测试对于确保配置系统的可靠性和稳定性至关重要。通过测试配置的注册、保存、加载、重新加载等功能，可以验证配置系统在各种情况下的行为是否符合预期。

本指南提供了一系列测试用例和最佳实践，帮助您为 Pek.Common 配置系统编写全面的单元测试。通过遵循这些指南，您可以确保配置系统在您的应用程序中正常工作，并在未来的更改中保持稳定。