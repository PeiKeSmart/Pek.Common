# Pek.Common 配置系统代码示例

本文档提供了 Pek.Common 配置系统的完整代码示例，帮助您快速理解和使用配置系统。

## 基本配置类示例

以下是一个基本配置类的完整示例，包括 AOT 兼容性设置：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 为 AOT 兼容性创建 JsonSerializerContext
    [JsonSerializable(typeof(AppConfig))]
    public partial class AppConfigJsonContext : JsonSerializerContext
    {
    }

    // 定义配置类
    public class AppConfig : Config<AppConfig>
    {
        // 配置属性，包含默认值
        public string ApplicationName { get; set; } = "我的应用";
        public bool DebugMode { get; set; } = false;
        public int CacheTimeoutMinutes { get; set; } = 30;
        public List<string> EnabledModules { get; set; } = new List<string> { "Core", "UI" };

        // 静态构造函数，注册配置
        static AppConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppConfig>(options);
        }
    }
}
```

## 使用配置的示例

以下是如何在应用程序中使用配置的示例：

```csharp
using MyApp.Configuration;
using System;

namespace MyApp
{
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 初始化配置（AOT 环境下）
                InitializeConfigs();

                // 读取配置
                var config = AppConfig.Current;
                Console.WriteLine($"应用名称: {config.ApplicationName}");
                Console.WriteLine($"调试模式: {config.DebugMode}");
                Console.WriteLine($"缓存超时: {config.CacheTimeoutMinutes}分钟");
                Console.WriteLine($"已启用模块: {string.Join(", ", config.EnabledModules)}");

                // 修改配置
                config.DebugMode = true;
                config.CacheTimeoutMinutes = 15;
                config.EnabledModules.Add("Analytics");

                // 保存配置
                config.Save();
                Console.WriteLine("配置已保存");

                // 重新加载配置
                AppConfig.Reload();
                var reloadedConfig = AppConfig.Current;
                Console.WriteLine($"重新加载后的调试模式: {reloadedConfig.DebugMode}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置操作失败: {ex.Message}");
            }
        }

        // AOT 环境下的配置初始化
        private static void InitializeConfigs()
        {
            try
            {
                // 手动注册配置
                var jsonOptions = new JsonSerializerOptions
                {
                    TypeInfoResolver = AppConfigJsonContext.Default,
                    WriteIndented = true,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                };

                ConfigManager.RegisterConfig<AppConfig>(jsonOptions);

                // 触发初始化
                var config = AppConfig.Current;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置初始化失败: {ex.Message}");
            }
        }
    }
}
```

## 多配置类示例

以下是使用多个配置类的示例：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 数据库配置的 JsonSerializerContext
    [JsonSerializable(typeof(DatabaseConfig))]
    public partial class DatabaseConfigJsonContext : JsonSerializerContext
    {
    }

    // 日志配置的 JsonSerializerContext
    [JsonSerializable(typeof(LoggingConfig))]
    public partial class LoggingConfigJsonContext : JsonSerializerContext
    {
    }

    // 数据库配置类
    public class DatabaseConfig : Config<DatabaseConfig>
    {
        public string ConnectionString { get; set; } = "Server=localhost;Database=MyApp;Trusted_Connection=True;";
        public int CommandTimeout { get; set; } = 30;
        public bool UsePooling { get; set; } = true;
        public int MaxPoolSize { get; set; } = 100;

        static DatabaseConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = DatabaseConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<DatabaseConfig>(options);
        }
    }

    // 日志配置类
    public class LoggingConfig : Config<LoggingConfig>
    {
        public string LogLevel { get; set; } = "Information";
        public bool EnableConsoleLogging { get; set; } = true;
        public bool EnableFileLogging { get; set; } = true;
        public string LogFilePath { get; set; } = "logs/app.log";
        public int MaxLogFileSizeMB { get; set; } = 10;
        public int MaxLogFileCount { get; set; } = 5;

        static LoggingConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = LoggingConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<LoggingConfig>(options);
        }
    }
}
```

## 配置验证示例

以下是带有验证逻辑的配置类示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    [JsonSerializable(typeof(NetworkConfig))]
    public partial class NetworkConfigJsonContext : JsonSerializerContext
    {
    }

    public class NetworkConfig : Config<NetworkConfig>
    {
        public string Host { get; set; } = "localhost";
        public int Port { get; set; } = 8080;
        public int Timeout { get; set; } = 30;
        public int MaxConnections { get; set; } = 100;
        public bool EnableSsl { get; set; } = false;

        static NetworkConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = NetworkConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<NetworkConfig>(options);
        }

        // 重写 Save 方法添加验证逻辑
        public override void Save()
        {
            // 验证 Host
            if (string.IsNullOrWhiteSpace(Host))
            {
                throw new InvalidOperationException("Host 不能为空");
            }

            // 验证 Port
            if (Port <= 0 || Port > 65535)
            {
                throw new InvalidOperationException("Port 必须在 1-65535 范围内");
            }

            // 验证 Timeout
            if (Timeout <= 0)
            {
                throw new InvalidOperationException("Timeout 必须大于 0");
            }

            // 验证 MaxConnections
            if (MaxConnections <= 0)
            {
                throw new InvalidOperationException("MaxConnections 必须大于 0");
            }

            // 调用基类的 Save 方法
            base.Save();
        }
    }
}
```

## 配置变更通知示例

以下是实现配置变更通知的示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 配置变更事件参数
    public class ConfigChangedEventArgs : EventArgs
    {
        public string PropertyName { get; }
        public object? OldValue { get; }
        public object? NewValue { get; }

        public ConfigChangedEventArgs(string propertyName, object? oldValue, object? newValue)
        {
            PropertyName = propertyName;
            OldValue = oldValue;
            NewValue = newValue;
        }
    }

    [JsonSerializable(typeof(NotifyConfig))]
    public partial class NotifyConfigJsonContext : JsonSerializerContext
    {
    }

    public class NotifyConfig : Config<NotifyConfig>
    {
        // 配置变更事件
        public event EventHandler<ConfigChangedEventArgs>? ConfigChanged;

        // 带通知的属性
        private string _applicationName = "我的应用";
        public string ApplicationName
        {
            get => _applicationName;
            set
            {
                if (_applicationName != value)
                {
                    var oldValue = _applicationName;
                    _applicationName = value;
                    OnConfigChanged(new ConfigChangedEventArgs(nameof(ApplicationName), oldValue, value));
                }
            }
        }

        private bool _debugMode = false;
        public bool DebugMode
        {
            get => _debugMode;
            set
            {
                if (_debugMode != value)
                {
                    var oldValue = _debugMode;
                    _debugMode = value;
                    OnConfigChanged(new ConfigChangedEventArgs(nameof(DebugMode), oldValue, value));
                }
            }
        }

        static NotifyConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = NotifyConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<NotifyConfig>(options);
        }

        // 触发配置变更事件
        protected virtual void OnConfigChanged(ConfigChangedEventArgs e)
        {
            ConfigChanged?.Invoke(this, e);
        }
    }

    // 使用配置变更通知的示例
    public class ConfigNotificationExample
    {
        public void Run()
        {
            var config = NotifyConfig.Current;

            // 订阅配置变更事件
            config.ConfigChanged += OnConfigChanged;

            // 修改配置，将触发事件
            config.ApplicationName = "新应用名称";
            config.DebugMode = true;

            // 保存配置
            config.Save();
        }

        private void OnConfigChanged(object? sender, ConfigChangedEventArgs e)
        {
            Console.WriteLine($"配置已变更: {e.PropertyName}, 旧值: {e.OldValue}, 新值: {e.NewValue}");
        }
    }
}
```

## 依赖注入集成示例

以下是与依赖注入框架集成的示例：

```csharp
using Microsoft.Extensions.DependencyInjection;
using Pek.Configuration;
using System;

namespace MyApp.Configuration
{
    // 依赖注入扩展方法
    public static class ServiceCollectionExtensions
    {
        // 注册单个配置类
        public static IServiceCollection AddConfig<TConfig>(this IServiceCollection services)
            where TConfig : Config<TConfig>, new()
        {
            // 确保配置已初始化
            var config = Config<TConfig>.Current;
            
            // 注册为单例
            services.AddSingleton(config);
            
            return services;
        }

        // 注册所有配置类
        public static IServiceCollection AddAllConfigs(this IServiceCollection services)
        {
            // 注册各种配置
            services.AddConfig<AppConfig>();
            services.AddConfig<DatabaseConfig>();
            services.AddConfig<LoggingConfig>();
            services.AddConfig<NetworkConfig>();
            
            return services;
        }
    }

    // 使用依赖注入的服务示例
    public class ConfigurationService
    {
        private readonly AppConfig _appConfig;
        private readonly DatabaseConfig _dbConfig;

        // 通过构造函数注入配置
        public ConfigurationService(AppConfig appConfig, DatabaseConfig dbConfig)
        {
            _appConfig = appConfig;
            _dbConfig = dbConfig;
        }

        public void PrintConfigurations()
        {
            Console.WriteLine($"应用名称: {_appConfig.ApplicationName}");
            Console.WriteLine($"数据库连接: {_dbConfig.ConnectionString}");
        }
    }

    // 依赖注入设置示例
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            // 注册所有配置
            services.AddAllConfigs();

            // 注册使用配置的服务
            services.AddTransient<ConfigurationService>();
        }
    }
}
```

## 完整的 AOT 兼容性初始化示例

以下是在程序启动时进行 AOT 兼容性初始化的完整示例：

```csharp
using System;
using System.Text.Json;
using Pek.Configuration;
using MyApp.Configuration;

namespace MyApp
{
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 初始化所有配置（AOT 环境下）
                InitializeAllConfigs();

                Console.WriteLine("所有配置已成功初始化");

                // 使用配置...
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置初始化失败: {ex.Message}");
            }
        }

        // AOT 环境下的所有配置初始化
        private static void InitializeAllConfigs()
        {
            // 初始化 AppConfig
            InitializeConfig<AppConfig>(AppConfigJsonContext.Default);

            // 初始化 DatabaseConfig
            InitializeConfig<DatabaseConfig>(DatabaseConfigJsonContext.Default);

            // 初始化 LoggingConfig
            InitializeConfig<LoggingConfig>(LoggingConfigJsonContext.Default);

            // 初始化 NetworkConfig
            InitializeConfig<NetworkConfig>(NetworkConfigJsonContext.Default);
        }

        // 通用配置初始化方法
        private static void InitializeConfig<TConfig>(JsonSerializerContext jsonContext)
            where TConfig : Config<TConfig>, new()
        {
            try
            {
                // 创建 JsonSerializerOptions
                var jsonOptions = new JsonSerializerOptions
                {
                    TypeInfoResolver = jsonContext,
                    WriteIndented = true,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                };

                // 注册配置
                ConfigManager.RegisterConfig<TConfig>(jsonOptions);

                // 触发初始化
                var config = Config<TConfig>.Current;

                Console.WriteLine($"{typeof(TConfig).Name} 初始化成功");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"{typeof(TConfig).Name} 初始化失败: {ex.Message}");
                throw; // 重新抛出异常，允许调用者处理
            }
        }
    }
}
```

## 配置加密示例

以下是实现配置属性加密的示例：

```csharp
using System;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 加密 JSON 转换器
    public class EncryptedStringConverter : JsonConverter<string>
    {
        private static readonly byte[] Key = Encoding.UTF8.GetBytes("YourSecretKey12"); // 16字节密钥
        private static readonly byte[] IV = Encoding.UTF8.GetBytes("YourInitVector12"); // 16字节初始向量

        public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            // 读取加密的值
            string encryptedValue = reader.GetString() ?? string.Empty;
            if (string.IsNullOrEmpty(encryptedValue))
            {
                return string.Empty;
            }

            try
            {
                // 解密
                byte[] encryptedBytes = Convert.FromBase64String(encryptedValue);
                using var aes = Aes.Create();
                aes.Key = Key;
                aes.IV = IV;

                using var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
                using var ms = new System.IO.MemoryStream(encryptedBytes);
                using var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);
                using var reader2 = new System.IO.StreamReader(cs);
                return reader2.ReadToEnd();
            }
            catch
            {
                // 如果解密失败，返回原始值
                return encryptedValue;
            }
        }

        public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
        {
            if (string.IsNullOrEmpty(value))
            {
                writer.WriteStringValue(string.Empty);
                return;
            }

            // 加密
            using var aes = Aes.Create();
            aes.Key = Key;
            aes.IV = IV;

            using var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
            using var ms = new System.IO.MemoryStream();
            using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
            using (var sw = new System.IO.StreamWriter(cs))
            {
                sw.Write(value);
            }

            string encryptedValue = Convert.ToBase64String(ms.ToArray());
            writer.WriteStringValue(encryptedValue);
        }
    }

    [JsonSerializable(typeof(SecureConfig))]
    public partial class SecureConfigJsonContext : JsonSerializerContext
    {
    }

    public class SecureConfig : Config<SecureConfig>
    {
        public string Username { get; set; } = "admin";

        // 使用加密转换器的敏感属性
        [JsonConverter(typeof(EncryptedStringConverter))]
        public string Password { get; set; } = "password123";

        [JsonConverter(typeof(EncryptedStringConverter))]
        public string ApiKey { get; set; } = "sk_test_abcdefghijklmnopqrstuvwxyz";

        public bool RememberCredentials { get; set; } = false;

        static SecureConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = SecureConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<SecureConfig>(options);
        }
    }

    // 使用加密配置的示例
    public class SecureConfigExample
    {
        public void Run()
        {
            var config = SecureConfig.Current;

            // 读取敏感信息（已自动解密）
            Console.WriteLine($"用户名: {config.Username}");
            Console.WriteLine($"密码: {config.Password}"); // 显示解密后的密码
            Console.WriteLine($"API密钥: {config.ApiKey}"); // 显示解密后的API密钥

            // 修改敏感信息
            config.Password = "newPassword456";
            config.ApiKey = "sk_live_abcdefghijklmnopqrstuvwxyz";

            // 保存配置（敏感信息会自动加密）
            config.Save();
        }
    }
}
```

## 配置迁移示例

以下是实现配置版本迁移的示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    [JsonSerializable(typeof(VersionedConfig))]
    public partial class VersionedConfigJsonContext : JsonSerializerContext
    {
    }

    public class VersionedConfig : Config<VersionedConfig>
    {
        // 版本号，用于迁移
        public int Version { get; set; } = 1;

        // 版本1的属性
        public string Name { get; set; } = "默认名称";
        public bool Enabled { get; set; } = true;

        // 版本2新增的属性
        public int Timeout { get; set; } = 30;
        public string LogLevel { get; set; } = "Info";

        // 版本3新增的属性
        public string[] AllowedHosts { get; set; } = new[] { "localhost" };
        public bool EnableSsl { get; set; } = false;

        static VersionedConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = VersionedConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<VersionedConfig>(options);
        }

        // 重写 Reload 方法，添加迁移逻辑
        public new static void Reload()
        {
            // 调用基类的 Reload 方法
            Config<VersionedConfig>.Reload();

            // 获取重新加载的配置实例
            var config = Current;

            // 执行迁移
            config.MigrateIfNeeded();
        }

        // 配置迁移方法
        public void MigrateIfNeeded()
        {
            bool migrated = false;

            // 从版本1迁移到版本2
            if (Version < 2)
            {
                Console.WriteLine("正在从版本1迁移到版本2...");
                
                // 设置版本2新增属性的默认值
                Timeout = 30;
                LogLevel = "Info";
                
                Version = 2;
                migrated = true;
            }

            // 从版本2迁移到版本3
            if (Version < 3)
            {
                Console.WriteLine("正在从版本2迁移到版本3...");
                
                // 设置版本3新增属性的默认值
                AllowedHosts = new[] { "localhost" };
                EnableSsl = false;
                
                Version = 3;
                migrated = true;
            }

            // 如果进行了迁移，保存配置
            if (migrated)
            {
                Console.WriteLine("配置迁移完成，正在保存...");
                Save();
            }
        }
    }

    // 使用版本迁移的示例
    public class ConfigMigrationExample
    {
        public void Run()
        {
            // 重新加载配置（会触发迁移）
            VersionedConfig.Reload();

            var config = VersionedConfig.Current;
            Console.WriteLine($"当前配置版本: {config.Version}");

            // 使用配置...
        }
    }
}
```

## 多环境配置示例

以下是实现多环境配置的示例：

```csharp
using System;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 扩展 ConfigManager 以支持多环境
    public static class EnvironmentConfigManager
    {
        // 当前环境
        public static string Environment { get; private set; } = "Development";

        // 设置环境
        public static void SetEnvironment(string environment)
        {
            Environment = environment;
            Console.WriteLine($"已切换到 {environment} 环境");
        }

        // 获取环境特定的配置文件路径
        public static string GetEnvironmentConfigFilePath<TConfig>()
            where TConfig : Config<TConfig>, new()
        {
            string baseDir = AppDomain.CurrentDomain.BaseDirectory;
            string configDir = Path.Combine(baseDir, "Config", Environment);
            string fileName = $"{typeof(TConfig).Name}.config";
            return Path.Combine(configDir, fileName);
        }

        // 注册环境特定的配置
        public static void RegisterEnvironmentConfig<TConfig>(JsonSerializerOptions options)
            where TConfig : Config<TConfig>, new()
        {
            // 获取环境特定的配置文件路径
            string configFilePath = GetEnvironmentConfigFilePath<TConfig>();

            // 确保目录存在
            Directory.CreateDirectory(Path.GetDirectoryName(configFilePath) ?? string.Empty);

            // 注册配置，使用自定义文件路径
            ConfigManager.RegisterConfig<TConfig>(options, configFilePath);
        }
    }

    [JsonSerializable(typeof(EnvironmentConfig))]
    public partial class EnvironmentConfigJsonContext : JsonSerializerContext
    {
    }

    public class EnvironmentConfig : Config<EnvironmentConfig>
    {
        public string ApiUrl { get; set; } = "https://api.example.com";
        public string DatabaseConnectionString { get; set; } = "Server=localhost;Database=MyApp;";
        public bool EnableCaching { get; set; } = true;
        public int CacheTimeoutSeconds { get; set; } = 300;
        public string LogLevel { get; set; } = "Information";

        static EnvironmentConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = EnvironmentConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            // 使用环境特定的配置注册
            EnvironmentConfigManager.RegisterEnvironmentConfig<EnvironmentConfig>(options);
        }
    }

    // 使用多环境配置的示例
    public class MultiEnvironmentExample
    {
        public void Run()
        {
            // 开发环境
            EnvironmentConfigManager.SetEnvironment("Development");
            var devConfig = EnvironmentConfig.Current;
            Console.WriteLine($"开发环境 API URL: {devConfig.ApiUrl}");
            Console.WriteLine($"开发环境数据库连接: {devConfig.DatabaseConnectionString}");

            // 测试环境
            EnvironmentConfigManager.SetEnvironment("Testing");
            EnvironmentConfig.Reload(); // 重新加载以获取新环境的配置
            var testConfig = EnvironmentConfig.Current;
            Console.WriteLine($"测试环境 API URL: {testConfig.ApiUrl}");
            Console.WriteLine($"测试环境数据库连接: {testConfig.DatabaseConnectionString}");

            // 生产环境
            EnvironmentConfigManager.SetEnvironment("Production");
            EnvironmentConfig.Reload(); // 重新加载以获取新环境的配置
            var prodConfig = EnvironmentConfig.Current;
            Console.WriteLine($"生产环境 API URL: {prodConfig.ApiUrl}");
            Console.WriteLine($"生产环境数据库连接: {prodConfig.DatabaseConnectionString}");
        }
    }
}
```

## 配置工厂模式示例

以下是使用工厂模式创建配置的示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 配置工厂接口
    public interface IConfigFactory
    {
        T GetConfig<T>() where T : Config<T>, new();
        void ReloadConfig<T>() where T : Config<T>, new();
    }

    // 配置工厂实现
    public class ConfigFactory : IConfigFactory
    {
        // 获取配置实例
        public T GetConfig<T>() where T : Config<T>, new()
        {
            return Config<T>.Current;
        }

        // 重新加载配置
        public void ReloadConfig<T>() where T : Config<T>, new()
        {
            Config<T>.Reload();
        }
    }

    // 使用配置工厂的示例
    public class ConfigFactoryExample
    {
        private readonly IConfigFactory _configFactory;

        public ConfigFactoryExample(IConfigFactory configFactory)
        {
            _configFactory = configFactory;
        }

        public void Run()
        {
            // 获取 AppConfig
            var appConfig = _configFactory.GetConfig<AppConfig>();
            Console.WriteLine($"应用名称: {appConfig.ApplicationName}");

            // 获取 DatabaseConfig
            var dbConfig = _configFactory.GetConfig<DatabaseConfig>();
            Console.WriteLine($"数据库连接: {dbConfig.ConnectionString}");

            // 重新加载配置
            _configFactory.ReloadConfig<AppConfig>();
            var reloadedConfig = _configFactory.GetConfig<AppConfig>();
            Console.WriteLine($"重新加载后的应用名称: {reloadedConfig.ApplicationName}");
        }
    }

    // 依赖注入设置
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            // 注册配置工厂
            services.AddSingleton<IConfigFactory, ConfigFactory>();

            // 注册使用配置工厂的服务
            services.AddTransient<ConfigFactoryExample>();
        }
    }
}
```

## 配置系统优化示例

以下是配置系统性能优化的示例：

```csharp
using System;
using System.Collections.Concurrent;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 优化的配置管理器
    public static class OptimizedConfigManager
    {
        // 配置缓存
        private static readonly ConcurrentDictionary<Type, object> _configCache = new ConcurrentDictionary<Type, object>();

        // 脏标记跟踪
        private static readonly ConcurrentDictionary<Type, bool> _dirtyFlags = new ConcurrentDictionary<Type, bool>();

        // 保存锁
        private static readonly SemaphoreSlim _saveLock = new SemaphoreSlim(1, 1);

        // 保存计时器
        private static readonly ConcurrentDictionary<Type, Timer> _saveTimers = new ConcurrentDictionary<Type, Timer>();

        // 获取配置实例
        public static T GetConfig<T>() where T : Config<T>, new()
        {
            return (T)_configCache.GetOrAdd(typeof(T), _ => Config<T>.Current);
        }

        // 标记配置为脏（需要保存）
        public static void MarkDirty<T>() where T : Config<T>, new()
        {
            _dirtyFlags[typeof(T)] = true;

            // 设置延迟保存计时器
            if (!_saveTimers.ContainsKey(typeof(T)))
            {
                var timer = new Timer(SaveConfigCallback<T>, null, TimeSpan.FromSeconds(5), Timeout.InfiniteTimeSpan);
                _saveTimers[typeof(T)] = timer;
            }
            else
            {
                // 重置现有计时器
                _saveTimers[typeof(T)].Change(TimeSpan.FromSeconds(5), Timeout.InfiniteTimeSpan);
            }
        }

        // 保存配置回调
        private static async void SaveConfigCallback<T>(object? state) where T : Config<T>, new()
        {
            if (_dirtyFlags.TryGetValue(typeof(T), out bool isDirty) && isDirty)
            {
                await SaveConfigAsync<T>();
            }
        }

        // 异步保存配置
        public static async Task SaveConfigAsync<T>() where T : Config<T>, new()
        {
            await _saveLock.WaitAsync();
            try
            {
                if (_dirtyFlags.TryGetValue(typeof(T), out bool isDirty) && isDirty)
                {
                    var config = GetConfig<T>();
                    config.Save();
                    _dirtyFlags[typeof(T)] = false;
                }
            }
            finally
            {
                _saveLock.Release();
            }
        }

        // 重新加载配置
        public static void ReloadConfig<T>() where T : Config<T>, new()
        {
            Config<T>.Reload();
            if (_configCache.ContainsKey(typeof(T)))
            {
                _configCache[typeof(T)] = Config<T>.Current;
            }
        }
    }

    [JsonSerializable(typeof(OptimizedConfig))]
    public partial class OptimizedConfigJsonContext : JsonSerializerContext
    {
    }

    public class OptimizedConfig : Config<OptimizedConfig>
    {
        public string Name { get; set; } = "优化配置";
        public int Value { get; set; } = 100;
        public bool IsEnabled { get; set; } = true;

        static OptimizedConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = OptimizedConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<OptimizedConfig>(options);
        }

        // 重写 Save 方法，使用脏标记
        public override void Save()
        {
            // 标记为脏，延迟保存
            OptimizedConfigManager.MarkDirty<OptimizedConfig>();
        }
    }

    // 使用优化配置的示例
    public class OptimizedConfigExample
    {
        public async Task Run()
        {
            // 获取配置
            var config = OptimizedConfigManager.GetConfig<OptimizedConfig>();
            Console.WriteLine($"名称: {config.Name}");

            // 修改配置（会标记为脏，但不会立即保存）
            config.Name = "新名称";
            config.Value = 200;
            config.Save(); // 这里不会立即保存，而是延迟保存

            Console.WriteLine("配置已修改，将在5秒后自动保存...");

            // 等待保存完成
            await Task.Delay(6000);

            // 重新加载配置
            OptimizedConfigManager.ReloadConfig<OptimizedConfig>();
            var reloadedConfig = OptimizedConfigManager.GetConfig<OptimizedConfig>();
            Console.WriteLine($"重新加载后的名称: {reloadedConfig.Name}");
        }
    }
}
```

这些示例涵盖了 Pek.Common 配置系统的各种使用场景，从基本用法到高级功能。您可以根据自己的需求选择适合的示例，并根据实际情况进行调整。