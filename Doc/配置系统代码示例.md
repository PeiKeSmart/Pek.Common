# Pek.Common 配置系统代码示例

本文档提供了 Pek.Common 配置系统的完整代码示例，帮助您快速理解和使用配置系统。

## 基本配置类示例

以下是一个基本配置类的完整示例，包括 AOT 兼容性设置：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 为 AOT 兼容性创建 JsonSerializerContext
    [JsonSerializable(typeof(AppConfig))]
    public partial class AppConfigJsonContext : JsonSerializerContext
    {
    }

    // 定义配置类
    public class AppConfig : Config<AppConfig>
    {
        // 配置属性，包含默认值
        public string ApplicationName { get; set; } = "我的应用";
        public bool DebugMode { get; set; } = false;
        public int CacheTimeoutMinutes { get; set; } = 30;
        public List<string> EnabledModules { get; set; } = new List<string> { "Core", "UI" };

        // 静态构造函数，注册配置
        static AppConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = AppConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<AppConfig>(options);
        }
    }
}
```

## 使用配置的示例

以下是如何在应用程序中使用配置的示例：

```csharp
using MyApp.Configuration;
using System;

namespace MyApp
{
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 初始化配置（AOT 环境下）
                InitializeConfigs();

                // 读取配置
                var config = AppConfig.Current;
                Console.WriteLine($"应用名称: {config.ApplicationName}");
                Console.WriteLine($"调试模式: {config.DebugMode}");
                Console.WriteLine($"缓存超时: {config.CacheTimeoutMinutes}分钟");
                Console.WriteLine($"已启用模块: {string.Join(", ", config.EnabledModules)}");

                // 修改配置
                config.DebugMode = true;
                config.CacheTimeoutMinutes = 15;
                config.EnabledModules.Add("Analytics");

                // 保存配置
                config.Save();
                Console.WriteLine("配置已保存");

                // 重新加载配置
                AppConfig.Reload();
                var reloadedConfig = AppConfig.Current;
                Console.WriteLine($"重新加载后的调试模式: {reloadedConfig.DebugMode}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置操作失败: {ex.Message}");
            }
        }

        // AOT 环境下的配置初始化
        private static void InitializeConfigs()
        {
            try
            {
                // 手动注册配置
                var jsonOptions = new JsonSerializerOptions
                {
                    TypeInfoResolver = AppConfigJsonContext.Default,
                    WriteIndented = true,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                };

                ConfigManager.RegisterConfig<AppConfig>(jsonOptions);

                // 触发初始化
                var config = AppConfig.Current;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置初始化失败: {ex.Message}");
            }
        }
    }
}
```

## 多配置类示例

以下是使用多个配置类的示例：

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 数据库配置的 JsonSerializerContext
    [JsonSerializable(typeof(DatabaseConfig))]
    public partial class DatabaseConfigJsonContext : JsonSerializerContext
    {
    }

    // 日志配置的 JsonSerializerContext
    [JsonSerializable(typeof(LoggingConfig))]
    public partial class LoggingConfigJsonContext : JsonSerializerContext
    {
    }

    // 数据库配置类
    public class DatabaseConfig : Config<DatabaseConfig>
    {
        public string ConnectionString { get; set; } = "Server=localhost;Database=MyApp;Trusted_Connection=True;";
        public int CommandTimeout { get; set; } = 30;
        public bool UsePooling { get; set; } = true;
        public int MaxPoolSize { get; set; } = 100;

        static DatabaseConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = DatabaseConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<DatabaseConfig>(options);
        }
    }

    // 日志配置类
    public class LoggingConfig : Config<LoggingConfig>
    {
        public string LogLevel { get; set; } = "Information";
        public bool EnableConsoleLogging { get; set; } = true;
        public bool EnableFileLogging { get; set; } = true;
        public string LogFilePath { get; set; } = "logs/app.log";
        public int MaxLogFileSizeMB { get; set; } = 10;
        public int MaxLogFileCount { get; set; } = 5;

        static LoggingConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = LoggingConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<LoggingConfig>(options);
        }
    }
}
```

## 配置验证示例

以下是带有验证逻辑的配置类示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    [JsonSerializable(typeof(NetworkConfig))]
    public partial class NetworkConfigJsonContext : JsonSerializerContext
    {
    }

    public class NetworkConfig : Config<NetworkConfig>
    {
        public string Host { get; set; } = "localhost";
        public int Port { get; set; } = 8080;
        public int Timeout { get; set; } = 30;
        public int MaxConnections { get; set; } = 100;
        public bool EnableSsl { get; set; } = false;

        static NetworkConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = NetworkConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<NetworkConfig>(options);
        }

        // 重写 Save 方法添加验证逻辑
        public override void Save()
        {
            // 验证 Host
            if (string.IsNullOrWhiteSpace(Host))
            {
                throw new InvalidOperationException("Host 不能为空");
            }

            // 验证 Port
            if (Port <= 0 || Port > 65535)
            {
                throw new InvalidOperationException("Port 必须在 1-65535 范围内");
            }

            // 验证 Timeout
            if (Timeout <= 0)
            {
                throw new InvalidOperationException("Timeout 必须大于 0");
            }

            // 验证 MaxConnections
            if (MaxConnections <= 0)
            {
                throw new InvalidOperationException("MaxConnections 必须大于 0");
            }

            // 调用基类的 Save 方法
            base.Save();
        }
    }
}
```

## 配置变更通知示例

以下是实现配置变更通知的示例：

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Pek.Configuration;

namespace MyApp.Configuration
{
    // 配置变更事件参数
    public class ConfigChangedEventArgs : EventArgs
    {
        public string PropertyName { get; }
        public object? OldValue { get; }
        public object? NewValue { get; }

        public ConfigChangedEventArgs(string propertyName, object? oldValue, object? newValue)
        {
            PropertyName = propertyName;
            OldValue = oldValue;
            NewValue = newValue;
        }
    }

    [JsonSerializable(typeof(NotifyConfig))]
    public partial class NotifyConfigJsonContext : JsonSerializerContext
    {
    }

    public class NotifyConfig : Config<NotifyConfig>
    {
        // 配置变更事件
        public event EventHandler<ConfigChangedEventArgs>? ConfigChanged;

        // 带通知的属性
        private string _applicationName = "我的应用";
        public string ApplicationName
        {
            get => _applicationName;
            set
            {
                if (_applicationName != value)
                {
                    var oldValue = _applicationName;
                    _applicationName = value;
                    OnConfigChanged(new ConfigChangedEventArgs(nameof(ApplicationName), oldValue, value));
                }
            }
        }

        private bool _debugMode = false;
        public bool DebugMode
        {
            get => _debugMode;
            set
            {
                if (_debugMode != value)
                {
                    var oldValue = _debugMode;
                    _debugMode = value;
                    OnConfigChanged(new ConfigChangedEventArgs(nameof(DebugMode), oldValue, value));
                }
            }
        }

        static NotifyConfig()
        {
            var options = new JsonSerializerOptions
            {
                TypeInfoResolver = NotifyConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            ConfigManager.RegisterConfig<NotifyConfig>(options);
        }

        // 触发配置变更事件
        protected virtual void OnConfigChanged(ConfigChangedEventArgs e)
        {
            ConfigChanged?.Invoke(this, e);
        }
    }

    // 使用配置变更通知的示例
    public class ConfigNotificationExample
    {
        public void Run()
        {
            var config = NotifyConfig.Current;

            // 订阅配置变更事件
            config.ConfigChanged += OnConfigChanged;

            // 修改配置，将触发事件
            config.ApplicationName = "新应用名称";
            config.DebugMode = true;

            // 保存配置
            config.Save();
        }

        private void OnConfigChanged(object? sender, ConfigChangedEventArgs e)
        {
            Console.WriteLine($"配置已变更: {e.PropertyName}, 旧值: {e.OldValue}, 新值: {e.NewValue}");
        }
    }
}
```

## 依赖注入集成示例

以下是与依赖注入框架集成的示例：

```csharp
using Microsoft.Extensions.DependencyInjection;
using Pek.Configuration;
using System;

namespace MyApp.Configuration
{
    // 依赖注入扩展方法
    public static class ServiceCollectionExtensions
    {
        // 注册单个配置类
        public static IServiceCollection AddConfig<TConfig>(this IServiceCollection services)
            where TConfig : Config<TConfig>, new()
        {
            // 确保配置已初始化
            var config = Config<TConfig>.Current;
            
            // 注册为单例
            services.AddSingleton(config);
            
            return services;
        }

        // 注册所有配置类
        public static IServiceCollection AddAllConfigs(this IServiceCollection services)
        {
            // 注册各种配置
            services.AddConfig<AppConfig>();
            services.AddConfig<DatabaseConfig>();
            services.AddConfig<LoggingConfig>();
            services.AddConfig<NetworkConfig>();
            
            return services;
        }
    }

    // 使用依赖注入的服务示例
    public class ConfigurationService
    {
        private readonly AppConfig _appConfig;
        private readonly DatabaseConfig _dbConfig;

        // 通过构造函数注入配置
        public ConfigurationService(AppConfig appConfig, DatabaseConfig dbConfig)
        {
            _appConfig = appConfig;
            _dbConfig = dbConfig;
        }

        public void PrintConfigurations()
        {
            Console.WriteLine($"应用名称: {_appConfig.ApplicationName}");
            Console.WriteLine($"数据库连接: {_dbConfig.ConnectionString}");
        }
    }

    // 依赖注入设置示例
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            // 注册所有配置
            services.AddAllConfigs();

            // 注册使用配置的服务
            services.AddTransient<ConfigurationService>();
        }
    }
}
```

## 完整的 AOT 兼容性初始化示例

以下是在程序启动时进行 AOT 兼容性初始化的完整示例：

```csharp
using System;
using System.Text.Json;
using Pek.Configuration;
using MyApp.Configuration;

namespace MyApp
{
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                // 初始化所有配置（AOT 环境下）
                InitializeAllConfigs();

                Console.WriteLine("所有配置已成功初始化");

                // 使用配置...
            }
            catch (Exception ex)
            {
                Console.WriteLine($"配置初始化失败: {ex.Message}");
            }
        }

        // AOT 环境下的所有配置初始化
        private static void InitializeAllConfigs()
        {
            // 初始化 AppConfig
            InitializeConfig<AppConfig>(AppConfigJsonContext.Default);

            // 初始化 DatabaseConfig
            InitializeConfig<DatabaseConfig>(DatabaseConfigJsonContext.Default);

            // 初始化 LoggingConfig
            InitializeConfig<LoggingConfig>(LoggingConfigJsonContext.Default);

            // 初始化 NetworkConfig
            InitializeConfig<NetworkConfig>(NetworkConfigJsonContext.Default);
        }

        // 通用配置初始化方法
        private static void InitializeConfig<TConfig>(JsonSerializerContext jsonContext)
            where TConfig : Config<TConfig>, new()
        {
            try
            {
                // 创建 JsonSerializerOptions
                var jsonOptions = new JsonSerializerOptions
                {
                    TypeInfoResolver = jsonContext,
                    WriteIndented = true,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                };

                // 注册配置
                ConfigManager.RegisterConfig<TConfig>(jsonOptions);

                // 触发初始化
                var config = Config<TConfig>.Current;

                Console.WriteLine($"{typeof(TConfig).Name} 初始化成功");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"{typeof(TConfig).Name} 初始化失败: {ex.Message}");
                throw; // 重新抛出异常，允许调用者处理
            }
        }
    }
}
```

这些示例展示了配置系统的核心功能，专注于AOT兼容性和简单的使用模式。配置系统现在更加简洁，适合在各种环境中使用，包括AOT编译场景。