# Pek.Common 配置系统安全性指南

## 1. 简介

本文档提供了 Pek.Common 配置系统的安全性最佳实践和实现指南。配置系统通常包含敏感信息，如数据库连接字符串、API 密钥、密码等，因此确保这些信息的安全性至关重要。

### 1.1 安全目标

配置系统的安全性应该关注以下方面：

- 敏感数据加密
- 访问控制
- 安全存储
- 安全传输
- 审计和日志记录
- 配置验证
- 安全默认值

## 2. 敏感数据加密

### 2.1 属性级加密

实现属性级加密，只加密敏感属性：

```csharp
public class EncryptedAttribute : Attribute
{
    public string KeyName { get; set; }
    
    public EncryptedAttribute(string keyName = "DefaultKey")
    {
        KeyName = keyName;
    }
}

public class SecureConfig : Config<SecureConfig>
{
    public string ServerName { get; set; } = "localhost";
    
    [Encrypted]
    public string Password { get; set; } = "DefaultPassword";
    
    [Encrypted]
    public string ApiKey { get; set; } = "DefaultApiKey";
    
    [Encrypted("DatabaseKey")]
    public string ConnectionString { get; set; } = "Server=localhost;Database=mydb;User=user;Password=password";
    
    static SecureConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = SecureConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<SecureConfig>(options);
    }
}
```

### 2.2 加密服务实现

实现加密服务来处理敏感数据的加密和解密：

```csharp
public interface IEncryptionService
{
    string Encrypt(string plainText, string keyName);
    string Decrypt(string cipherText, string keyName);
}

public class AesEncryptionService : IEncryptionService
{
    private readonly Dictionary<string, byte[]> _keys;
    private readonly byte[] _iv;
    
    public AesEncryptionService()
    {
        // 在实际应用中，密钥应该从安全存储中获取，如 Azure Key Vault、AWS KMS 等
        _keys = new Dictionary<string, byte[]>
        {
            { "DefaultKey", GenerateKey("DefaultKey") },
            { "DatabaseKey", GenerateKey("DatabaseKey") }
        };
        
        // 初始化向量，在实际应用中应该安全存储
        _iv = new byte[16] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };
    }
    
    private byte[] GenerateKey(string seed)
    {
        // 在实际应用中，应该使用更安全的密钥生成方法
        using (var deriveBytes = new Rfc2898DeriveBytes(seed, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 }, 1000))
        {
            return deriveBytes.GetBytes(32); // 256 位密钥
        }
    }
    
    public string Encrypt(string plainText, string keyName)
    {
        if (string.IsNullOrEmpty(plainText))
        {
            return plainText;
        }
        
        if (!_keys.TryGetValue(keyName, out byte[] key))
        {
            throw new ArgumentException($"Key '{keyName}' not found.");
        }
        
        using (Aes aes = Aes.Create())
        {
            aes.Key = key;
            aes.IV = _iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            
            using (ICryptoTransform encryptor = aes.CreateEncryptor())
            using (MemoryStream ms = new MemoryStream())
            using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
            {
                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
                cs.Write(plainBytes, 0, plainBytes.Length);
                cs.FlushFinalBlock();
                
                return Convert.ToBase64String(ms.ToArray());
            }
        }
    }
    
    public string Decrypt(string cipherText, string keyName)
    {
        if (string.IsNullOrEmpty(cipherText))
        {
            return cipherText;
        }
        
        if (!_keys.TryGetValue(keyName, out byte[] key))
        {
            throw new ArgumentException($"Key '{keyName}' not found.");
        }
        
        using (Aes aes = Aes.Create())
        {
            aes.Key = key;
            aes.IV = _iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            
            using (ICryptoTransform decryptor = aes.CreateDecryptor())
            using (MemoryStream ms = new MemoryStream(Convert.FromBase64String(cipherText)))
            using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
            using (StreamReader sr = new StreamReader(cs, Encoding.UTF8))
            {
                return sr.ReadToEnd();
            }
        }
    }
}
```

### 2.3 加密配置处理器

实现配置处理器来自动处理加密和解密：

```csharp
public class SecureConfigProcessor
{
    private readonly IEncryptionService _encryptionService;
    
    public SecureConfigProcessor(IEncryptionService encryptionService)
    {
        _encryptionService = encryptionService;
    }
    
    public void ProcessBeforeSave<TConfig>(TConfig config) where TConfig : class
    {
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string plainValue = (string)property.GetValue(config);
                if (!string.IsNullOrEmpty(plainValue))
                {
                    string encryptedValue = _encryptionService.Encrypt(plainValue, encryptedAttr.KeyName);
                    property.SetValue(config, encryptedValue);
                }
            }
        }
    }
    
    public void ProcessAfterLoad<TConfig>(TConfig config) where TConfig : class
    {
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string encryptedValue = (string)property.GetValue(config);
                if (!string.IsNullOrEmpty(encryptedValue))
                {
                    string decryptedValue = _encryptionService.Decrypt(encryptedValue, encryptedAttr.KeyName);
                    property.SetValue(config, decryptedValue);
                }
            }
        }
    }
}
```

### 2.4 集成加密到配置系统

将加密服务集成到配置系统中：

```csharp
public class SecureConfigManager
{
    private static readonly IEncryptionService _encryptionService = new AesEncryptionService();
    private static readonly SecureConfigProcessor _configProcessor = new SecureConfigProcessor(_encryptionService);
    
    public static TConfig GetConfig<TConfig>(bool forceReload = false) where TConfig : class, new()
    {
        TConfig config = ConfigManager.GetConfig<TConfig>(forceReload);
        _configProcessor.ProcessAfterLoad(config);
        return config;
    }
    
    public static void SaveConfig<TConfig>(TConfig config) where TConfig : class
    {
        // 创建配置的副本，以避免修改原始配置
        TConfig configCopy = JsonSerializer.Deserialize<TConfig>(JsonSerializer.Serialize(config));
        
        // 处理加密
        _configProcessor.ProcessBeforeSave(configCopy);
        
        // 保存加密后的配置
        ConfigManager.SaveConfig(configCopy);
    }
}
```

### 2.5 使用安全配置

使用安全配置系统：

```csharp
// 获取配置
var secureConfig = SecureConfigManager.GetConfig<SecureConfig>();

// 使用配置（值已解密）
string connectionString = secureConfig.ConnectionString;
string apiKey = secureConfig.ApiKey;

// 修改配置
secureConfig.Password = "NewSecurePassword";

// 保存配置（值会被加密）
SecureConfigManager.SaveConfig(secureConfig);
```

## 3. 访问控制

### 3.1 基于角色的访问控制

实现基于角色的访问控制：

```csharp
public enum ConfigAccessLevel
{
    Read,
    Write,
    Admin
}

public class ConfigAccessControlAttribute : Attribute
{
    public ConfigAccessLevel MinimumAccessLevel { get; }
    
    public ConfigAccessControlAttribute(ConfigAccessLevel minimumAccessLevel)
    {
        MinimumAccessLevel = minimumAccessLevel;
    }
}

public class RoleBasedConfig : Config<RoleBasedConfig>
{
    // 所有角色都可以读取
    [ConfigAccessControl(ConfigAccessLevel.Read)]
    public string PublicSetting { get; set; } = "Public";
    
    // 需要写入权限
    [ConfigAccessControl(ConfigAccessLevel.Write)]
    public string RestrictedSetting { get; set; } = "Restricted";
    
    // 需要管理员权限
    [ConfigAccessControl(ConfigAccessLevel.Admin)]
    public string AdminSetting { get; set; } = "Admin";
    
    static RoleBasedConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = RoleBasedConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<RoleBasedConfig>(options);
    }
}
```

### 3.2 访问控制服务

实现访问控制服务：

```csharp
public interface IConfigAccessControlService
{
    bool CanAccess(PropertyInfo property, ConfigAccessLevel userAccessLevel);
    ConfigAccessLevel GetCurrentUserAccessLevel();
}

public class ConfigAccessControlService : IConfigAccessControlService
{
    public bool CanAccess(PropertyInfo property, ConfigAccessLevel userAccessLevel)
    {
        ConfigAccessControlAttribute accessAttr = property.GetCustomAttribute<ConfigAccessControlAttribute>();
        if (accessAttr == null)
        {
            // 如果没有访问控制属性，默认允许访问
            return true;
        }
        
        return userAccessLevel >= accessAttr.MinimumAccessLevel;
    }
    
    public ConfigAccessLevel GetCurrentUserAccessLevel()
    {
        // 在实际应用中，应该从身份验证系统获取当前用户的访问级别
        // 这里简单返回一个固定值作为示例
        return ConfigAccessLevel.Write;
    }
}
```

### 3.3 安全代理配置

实现安全代理配置，控制对配置属性的访问：

```csharp
public class SecureConfigProxy<TConfig> where TConfig : class
{
    private readonly TConfig _config;
    private readonly IConfigAccessControlService _accessControlService;
    
    public SecureConfigProxy(TConfig config, IConfigAccessControlService accessControlService)
    {
        _config = config;
        _accessControlService = accessControlService;
    }
    
    public TValue GetValue<TValue>(Expression<Func<TConfig, TValue>> propertySelector)
    {
        MemberExpression memberExpr = propertySelector.Body as MemberExpression;
        if (memberExpr == null)
        {
            throw new ArgumentException("Expression must be a member access expression.");
        }
        
        PropertyInfo property = memberExpr.Member as PropertyInfo;
        if (property == null)
        {
            throw new ArgumentException("Expression must be a property access expression.");
        }
        
        ConfigAccessLevel userAccessLevel = _accessControlService.GetCurrentUserAccessLevel();
        if (!_accessControlService.CanAccess(property, userAccessLevel))
        {
            throw new UnauthorizedAccessException($"Access to property '{property.Name}' is denied.");
        }
        
        Func<TConfig, TValue> getter = propertySelector.Compile();
        return getter(_config);
    }
    
    public void SetValue<TValue>(Expression<Func<TConfig, TValue>> propertySelector, TValue value)
    {
        MemberExpression memberExpr = propertySelector.Body as MemberExpression;
        if (memberExpr == null)
        {
            throw new ArgumentException("Expression must be a member access expression.");
        }
        
        PropertyInfo property = memberExpr.Member as PropertyInfo;
        if (property == null)
        {
            throw new ArgumentException("Expression must be a property access expression.");
        }
        
        ConfigAccessLevel userAccessLevel = _accessControlService.GetCurrentUserAccessLevel();
        if (!_accessControlService.CanAccess(property, userAccessLevel) || userAccessLevel < ConfigAccessLevel.Write)
        {
            throw new UnauthorizedAccessException($"Write access to property '{property.Name}' is denied.");
        }
        
        property.SetValue(_config, value);
    }
}
```

### 3.4 使用安全代理

使用安全代理访问配置：

```csharp
// 创建访问控制服务
var accessControlService = new ConfigAccessControlService();

// 获取配置
var config = RoleBasedConfig.Current;

// 创建安全代理
var secureProxy = new SecureConfigProxy<RoleBasedConfig>(config, accessControlService);

// 安全访问配置
try
{
    // 读取公共设置（允许）
    string publicSetting = secureProxy.GetValue(c => c.PublicSetting);
    Console.WriteLine($"Public setting: {publicSetting}");
    
    // 读取受限设置（允许，因为当前用户有写入权限）
    string restrictedSetting = secureProxy.GetValue(c => c.RestrictedSetting);
    Console.WriteLine($"Restricted setting: {restrictedSetting}");
    
    // 尝试读取管理员设置（拒绝，因为当前用户没有管理员权限）
    string adminSetting = secureProxy.GetValue(c => c.AdminSetting);
    Console.WriteLine($"Admin setting: {adminSetting}");
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Access denied: {ex.Message}");
}

// 尝试修改设置
try
{
    // 修改公共设置（允许，因为当前用户有写入权限）
    secureProxy.SetValue(c => c.PublicSetting, "Modified public setting");
    
    // 修改受限设置（允许，因为当前用户有写入权限）
    secureProxy.SetValue(c => c.RestrictedSetting, "Modified restricted setting");
    
    // 尝试修改管理员设置（拒绝，因为当前用户没有管理员权限）
    secureProxy.SetValue(c => c.AdminSetting, "Modified admin setting");
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Access denied: {ex.Message}");
}
```

## 4. 安全存储

### 4.1 使用安全存储提供程序

实现安全存储提供程序接口：

```csharp
public interface ISecureStorageProvider
{
    Task<string> GetSecretAsync(string secretName);
    Task SetSecretAsync(string secretName, string secretValue);
    Task DeleteSecretAsync(string secretName);
}
```

### 4.2 实现基于 DPAPI 的安全存储

使用 Windows 数据保护 API (DPAPI) 实现安全存储：

```csharp
public class DpapiSecureStorageProvider : ISecureStorageProvider
{
    private readonly string _storageDirectory;
    
    public DpapiSecureStorageProvider(string storageDirectory = null)
    {
        _storageDirectory = storageDirectory ?? Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "MyApp",
            "SecureStorage");
        
        Directory.CreateDirectory(_storageDirectory);
    }
    
    public Task<string> GetSecretAsync(string secretName)
    {
        string filePath = GetSecretFilePath(secretName);
        if (!File.Exists(filePath))
        {
            return Task.FromResult<string>(null);
        }
        
        byte[] encryptedData = File.ReadAllBytes(filePath);
        byte[] decryptedData = ProtectedData.Unprotect(encryptedData, null, DataProtectionScope.CurrentUser);
        string secretValue = Encoding.UTF8.GetString(decryptedData);
        
        return Task.FromResult(secretValue);
    }
    
    public Task SetSecretAsync(string secretName, string secretValue)
    {
        byte[] data = Encoding.UTF8.GetBytes(secretValue);
        byte[] encryptedData = ProtectedData.Protect(data, null, DataProtectionScope.CurrentUser);
        
        string filePath = GetSecretFilePath(secretName);
        File.WriteAllBytes(filePath, encryptedData);
        
        return Task.CompletedTask;
    }
    
    public Task DeleteSecretAsync(string secretName)
    {
        string filePath = GetSecretFilePath(secretName);
        if (File.Exists(filePath))
        {
            File.Delete(filePath);
        }
        
        return Task.CompletedTask;
    }
    
    private string GetSecretFilePath(string secretName)
    {
        // 使用 SHA256 哈希作为文件名，避免特殊字符问题
        using (SHA256 sha256 = SHA256.Create())
        {
            byte[] hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(secretName));
            string hashString = BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
            return Path.Combine(_storageDirectory, $"{hashString}.bin");
        }
    }
}
```

### 4.3 安全配置提供程序

实现安全配置提供程序，将敏感信息存储在安全存储中：

```csharp
public class SecureConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly ISecureStorageProvider _secureStorage;
    private readonly string _configPrefix;
    
    public SecureConfigProvider(ISecureStorageProvider secureStorage, string configPrefix = null)
    {
        _secureStorage = secureStorage;
        _configPrefix = configPrefix ?? typeof(TConfig).Name;
    }
    
    public async Task<TConfig> LoadConfigAsync()
    {
        TConfig config = ConfigManager.GetConfig<TConfig>();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string secretName = GetSecretName(property.Name);
                string secretValue = await _secureStorage.GetSecretAsync(secretName);
                
                if (!string.IsNullOrEmpty(secretValue))
                {
                    property.SetValue(config, secretValue);
                }
            }
        }
        
        return config;
    }
    
    public async Task SaveConfigAsync(TConfig config)
    {
        // 保存非敏感配置到配置文件
        TConfig configCopy = JsonSerializer.Deserialize<TConfig>(JsonSerializer.Serialize(config));
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string secretName = GetSecretName(property.Name);
                string secretValue = (string)property.GetValue(config);
                
                if (!string.IsNullOrEmpty(secretValue))
                {
                    await _secureStorage.SetSecretAsync(secretName, secretValue);
                    
                    // 在配置文件中使用占位符
                    property.SetValue(configCopy, "[SECURED]");
                }
            }
        }
        
        ConfigManager.SaveConfig(configCopy);
    }
    
    private string GetSecretName(string propertyName)
    {
        return $"{_configPrefix}_{propertyName}";
    }
}
```

### 4.4 使用安全配置提供程序

使用安全配置提供程序：

```csharp
// 创建安全存储提供程序
var secureStorage = new DpapiSecureStorageProvider();

// 创建安全配置提供程序
var secureConfigProvider = new SecureConfigProvider<SecureConfig>(secureStorage);

// 加载配置
SecureConfig config = await secureConfigProvider.LoadConfigAsync();

// 使用配置
string connectionString = config.ConnectionString;
string apiKey = config.ApiKey;

// 修改配置
config.Password = "NewSecurePassword";

// 保存配置
await secureConfigProvider.SaveConfigAsync(config);
```

## 5. 安全传输

### 5.1 配置传输加密

实现配置传输加密：

```csharp
public class ConfigTransportEncryption
{
    private readonly X509Certificate2 _certificate;
    
    public ConfigTransportEncryption(X509Certificate2 certificate)
    {
        _certificate = certificate;
    }
    
    public string EncryptConfig<TConfig>(TConfig config) where TConfig : class
    {
        string json = JsonSerializer.Serialize(config);
        byte[] jsonBytes = Encoding.UTF8.GetBytes(json);
        
        using (RSA rsa = _certificate.GetRSAPublicKey())
        {
            // 对于大型配置，应该使用混合加密（对称加密 + 非对称加密）
            // 这里简化为直接使用 RSA，适用于小型配置
            byte[] encryptedBytes = rsa.Encrypt(jsonBytes, RSAEncryptionPadding.OaepSHA256);
            return Convert.ToBase64String(encryptedBytes);
        }
    }
    
    public TConfig DecryptConfig<TConfig>(string encryptedConfig) where TConfig : class
    {
        byte[] encryptedBytes = Convert.FromBase64String(encryptedConfig);
        
        using (RSA rsa = _certificate.GetRSAPrivateKey())
        {
            byte[] decryptedBytes = rsa.Decrypt(encryptedBytes, RSAEncryptionPadding.OaepSHA256);
            string json = Encoding.UTF8.GetString(decryptedBytes);
            return JsonSerializer.Deserialize<TConfig>(json);
        }
    }
}
```

### 5.2 配置传输签名

实现配置传输签名：

```csharp
public class ConfigTransportSigning
{
    private readonly X509Certificate2 _certificate;
    
    public ConfigTransportSigning(X509Certificate2 certificate)
    {
        _certificate = certificate;
    }
    
    public string SignConfig<TConfig>(TConfig config) where TConfig : class
    {
        string json = JsonSerializer.Serialize(config);
        byte[] jsonBytes = Encoding.UTF8.GetBytes(json);
        
        using (RSA rsa = _certificate.GetRSAPrivateKey())
        {
            byte[] signature = rsa.SignData(jsonBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            
            var signedData = new
            {
                Config = json,
                Signature = Convert.ToBase64String(signature)
            };
            
            return JsonSerializer.Serialize(signedData);
        }
    }
    
    public TConfig VerifyAndGetConfig<TConfig>(string signedConfig) where TConfig : class
    {
        var signedData = JsonSerializer.Deserialize<SignedData>(signedConfig);
        byte[] jsonBytes = Encoding.UTF8.GetBytes(signedData.Config);
        byte[] signature = Convert.FromBase64String(signedData.Signature);
        
        using (RSA rsa = _certificate.GetRSAPublicKey())
        {
            bool isValid = rsa.VerifyData(jsonBytes, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            if (!isValid)
            {
                throw new SecurityException("Config signature verification failed.");
            }
            
            return JsonSerializer.Deserialize<TConfig>(signedData.Config);
        }
    }
    
    private class SignedData
    {
        public string Config { get; set; }
        public string Signature { get; set; }
    }
}
```

## 6. 审计和日志记录

### 6.1 配置访问审计

实现配置访问审计：

```csharp
public interface IConfigAuditService
{
    void LogAccess<TConfig>(string propertyName, string operation, string userName);
    IEnumerable<ConfigAuditEntry> GetAuditLog<TConfig>();
}

public class ConfigAuditEntry
{
    public string ConfigType { get; set; }
    public string PropertyName { get; set; }
    public string Operation { get; set; }
    public string UserName { get; set; }
    public DateTime Timestamp { get; set; }
}

public class ConfigAuditService : IConfigAuditService
{
    private readonly List<ConfigAuditEntry> _auditLog = new List<ConfigAuditEntry>();
    private readonly object _lockObject = new object();
    
    public void LogAccess<TConfig>(string propertyName, string operation, string userName)
    {
        var entry = new ConfigAuditEntry
        {
            ConfigType = typeof(TConfig).Name,
            PropertyName = propertyName,
            Operation = operation,
            UserName = userName,
            Timestamp = DateTime.UtcNow
        };
        
        lock (_lockObject)
        {
            _auditLog.Add(entry);
        }
        
        // 在实际应用中，应该将审计日志保存到持久存储，如数据库或日志文件
    }
    
    public IEnumerable<ConfigAuditEntry> GetAuditLog<TConfig>()
    {
        lock (_lockObject)
        {
            return _auditLog
                .Where(e => e.ConfigType == typeof(TConfig).Name)
                .OrderByDescending(e => e.Timestamp)
                .ToList();
        }
    }
}
```

### 6.2 审计代理

实现审计代理：

```csharp
public class AuditConfigProxy<TConfig> where TConfig : class
{
    private readonly TConfig _config;
    private readonly IConfigAuditService _auditService;
    private readonly string _userName;
    
    public AuditConfigProxy(TConfig config, IConfigAuditService auditService, string userName)
    {
        _config = config;
        _auditService = auditService;
        _userName = userName;
    }
    
    public TValue GetValue<TValue>(Expression<Func<TConfig, TValue>> propertySelector)
    {
        MemberExpression memberExpr = propertySelector.Body as MemberExpression;
        if (memberExpr == null)
        {
            throw new ArgumentException("Expression must be a member access expression.");
        }
        
        PropertyInfo property = memberExpr.Member as PropertyInfo;
        if (property == null)
        {
            throw new ArgumentException("Expression must be a property access expression.");
        }
        
        // 记录访问
        _auditService.LogAccess<TConfig>(property.Name, "Read", _userName);
        
        Func<TConfig, TValue> getter = propertySelector.Compile();
        return getter(_config);
    }
    
    public void SetValue<TValue>(Expression<Func<TConfig, TValue>> propertySelector, TValue value)
    {
        MemberExpression memberExpr = propertySelector.Body as MemberExpression;
        if (memberExpr == null)
        {
            throw new ArgumentException("Expression must be a member access expression.");
        }
        
        PropertyInfo property = memberExpr.Member as PropertyInfo;
        if (property == null)
        {
            throw new ArgumentException("Expression must be a property access expression.");
        }
        
        // 记录修改
        _auditService.LogAccess<TConfig>(property.Name, "Write", _userName);
        
        property.SetValue(_config, value);
    }
}
```

### 6.3 使用审计代理

使用审计代理：

```csharp
// 创建审计服务
var auditService = new ConfigAuditService();

// 获取配置
var config = SecureConfig.Current;

// 创建审计代理
var auditProxy = new AuditConfigProxy<SecureConfig>(config, auditService, "admin");

// 使用审计代理访问配置
string serverName = auditProxy.GetValue(c => c.ServerName);
string password = auditProxy.GetValue(c => c.Password);

// 修改配置
auditProxy.SetValue(c => c.ServerName, "newserver");
auditProxy.SetValue(c => c.Password, "newpassword");

// 获取审计日志
var auditLog = auditService.GetAuditLog<SecureConfig>();
foreach (var entry in auditLog)
{
    Console.WriteLine($"{entry.Timestamp}: {entry.UserName} {entry.Operation} {entry.PropertyName}");
}
```

## 7. 配置验证

### 7.1 验证属性

实现验证属性：

```csharp
public class RequiredAttribute : Attribute { }

public class RangeAttribute : Attribute
{
    public double Minimum { get; }
    public double Maximum { get; }
    
    public RangeAttribute(double minimum, double maximum)
    {
        Minimum = minimum;
        Maximum = maximum;
    }
}

public class RegexAttribute : Attribute
{
    public string Pattern { get; }
    
    public RegexAttribute(string pattern)
    {
        Pattern = pattern;
    }
}

public class MinLengthAttribute : Attribute
{
    public int Length { get; }
    
    public MinLengthAttribute(int length)
    {
        Length = length;
    }
}
```

### 7.2 验证服务

实现验证服务：

```csharp
public interface IConfigValidationService
{
    ValidationResult Validate<TConfig>(TConfig config);
}

public class ValidationResult
{
    public bool IsValid => Errors.Count == 0;
    public Dictionary<string, List<string>> Errors { get; } = new Dictionary<string, List<string>>();
    
    public void AddError(string propertyName, string errorMessage)
    {
        if (!Errors.TryGetValue(propertyName, out List<string> propertyErrors))
        {
            propertyErrors = new List<string>();
            Errors[propertyName] = propertyErrors;
        }
        
        propertyErrors.Add(errorMessage);
    }
}

public class ConfigValidationService : IConfigValidationService
{
    public ValidationResult Validate<TConfig>(TConfig config)
    {
        var result = new ValidationResult();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            ValidateProperty(config, property, result);
        }
        
        return result;
    }
    
    private void ValidateProperty<TConfig>(TConfig config, PropertyInfo property, ValidationResult result)
    {
        object value = property.GetValue(config);
        
        // 验证 Required
        if (property.GetCustomAttribute<RequiredAttribute>() != null)
        {
            if (value == null || (value is string str && string.IsNullOrWhiteSpace(str)))
            {
                result.AddError(property.Name, "This field is required.");
            }
        }
        
        // 验证 Range
        RangeAttribute rangeAttr = property.GetCustomAttribute<RangeAttribute>();
        if (rangeAttr != null && value != null)
        {
            if (value is int intValue)
            {
                if (intValue < rangeAttr.Minimum || intValue > rangeAttr.Maximum)
                {
                    result.AddError(property.Name, $"Value must be between {rangeAttr.Minimum} and {rangeAttr.Maximum}.");
                }
            }
            else if (value is double doubleValue)
            {
                if (doubleValue < rangeAttr.Minimum || doubleValue > rangeAttr.Maximum)
                {
                    result.AddError(property.Name, $"Value must be between {rangeAttr.Minimum} and {rangeAttr.Maximum}.");
                }
            }
        }
        
        // 验证 Regex
        RegexAttribute regexAttr = property.GetCustomAttribute<RegexAttribute>();
        if (regexAttr != null && value is string strValue && !string.IsNullOrEmpty(strValue))
        {
            if (!Regex.IsMatch(strValue, regexAttr.Pattern))
            {
                result.AddError(property.Name, "Value does not match the required pattern.");
            }
        }
        
        // 验证 MinLength
        MinLengthAttribute minLengthAttr = property.GetCustomAttribute<MinLengthAttribute>();
        if (minLengthAttr != null && value is string strValue2 && !string.IsNullOrEmpty(strValue2))
        {
            if (strValue2.Length < minLengthAttr.Length)
            {
                result.AddError(property.Name, $"Value must be at least {minLengthAttr.Length} characters long.");
            }
        }
    }
}
```

### 7.3 验证配置类

实现带验证的配置类：

```csharp
public class ValidatedConfig : Config<ValidatedConfig>
{
    [Required]
    public string ServerName { get; set; } = "localhost";
    
    [Required]
    [MinLength(8)]
    [Regex("^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,}$")] // 强密码要求
    [Encrypted]
    public string Password { get; set; } = "P@ssw0rd";
    
    [Range(1, 65535)]
    public int Port { get; set; } = 1433;
    
    [Range(1, 3600)]
    public int TimeoutSeconds { get; set; } = 30;
    
    static ValidatedConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = ValidatedConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<ValidatedConfig>(options);
    }
}
```

### 7.4 使用验证服务

使用验证服务：

```csharp
// 创建验证服务
var validationService = new ConfigValidationService();

// 获取配置
var config = ValidatedConfig.Current;

// 修改配置
config.ServerName = "";
config.Password = "weak";
config.Port = 70000;
config.TimeoutSeconds = 0;

// 验证配置
var validationResult = validationService.Validate(config);

if (!validationResult.IsValid)
{
    Console.WriteLine("Configuration validation failed:");
    foreach (var error in validationResult.Errors)
    {
        Console.WriteLine($"Property: {error.Key}");
        foreach (var message in error.Value)
        {
            Console.WriteLine($"  - {message}");
        }
    }
}
else
{
    // 保存配置
    config.Save();
}
```

## 8. 安全默认值

### 8.1 安全默认值提供程序

实现安全默认值提供程序：

```csharp
public interface ISecureDefaultValueProvider
{
    object GetSecureDefault(Type propertyType, string propertyName);
}

public class SecureDefaultValueProvider : ISecureDefaultValueProvider
{
    private readonly Dictionary<string, object> _secureDefaults = new Dictionary<string, object>
    {
        { "Password", "P@ssw0rd123!" },
        { "ApiKey", Guid.NewGuid().ToString("N") },
        { "Secret", Convert.ToBase64String(Guid.NewGuid().ToByteArray()) },
        { "ConnectionString", "Server=localhost;Database=mydb;Integrated Security=True;" }
    };
    
    public object GetSecureDefault(Type propertyType, string propertyName)
    {
        // 根据属性名称查找安全默认值
        foreach (var key in _secureDefaults.Keys)
        {
            if (propertyName.Contains(key, StringComparison.OrdinalIgnoreCase))
            {
                return _secureDefaults[key];
            }
        }
        
        // 根据属性类型提供默认值
        if (propertyType == typeof(string))
        {
            return Guid.NewGuid().ToString("N");
        }
        else if (propertyType == typeof(int))
        {
            return 0;
        }
        else if (propertyType == typeof(bool))
        {
            return false;
        }
        
        return null;
    }
}
```

### 8.2 安全默认值配置

实现使用安全默认值的配置：

```csharp
public class SecureDefaultConfig : Config<SecureDefaultConfig>
{
    private static readonly ISecureDefaultValueProvider _defaultValueProvider = new SecureDefaultValueProvider();
    
    private string _password;
    public string Password
    {
        get => _password;
        set => _password = value;
    }
    
    private string _apiKey;
    public string ApiKey
    {
        get => _apiKey;
        set => _apiKey = value;
    }
    
    public SecureDefaultConfig()
    {
        // 使用安全默认值初始化属性
        _password = (string)_defaultValueProvider.GetSecureDefault(typeof(string), nameof(Password));
        _apiKey = (string)_defaultValueProvider.GetSecureDefault(typeof(string), nameof(ApiKey));
    }
    
    static SecureDefaultConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = SecureDefaultConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<SecureDefaultConfig>(options);
    }
}
```

## 9. 安全最佳实践

### 9.1 配置安全检查列表

- **敏感数据加密**：确保所有敏感数据在存储前都经过加密
- **访问控制**：实现基于角色的访问控制，限制对敏感配置的访问
- **安全存储**：使用安全存储提供程序存储敏感信息，如密钥和密码
- **安全传输**：在网络传输过程中加密和签名配置数据
- **审计和日志记录**：记录所有配置访问和修改操作
- **配置验证**：验证配置数据的有效性和安全性
- **安全默认值**：使用安全的默认值初始化配置
- **最小权限原则**：只授予必要的最小权限
- **定期轮换密钥**：定期更换加密密钥和敏感凭据
- **安全代码审查**：对配置系统代码进行安全审查

### 9.2 安全配置管理流程

1. **配置设计**：设计安全的配置结构，识别敏感数据
2. **配置实现**：实现配置类，使用加密和验证属性
3. **配置部署**：安全地部署配置，避免硬编码敏感信息
4. **配置访问**：使用安全代理控制对配置的访问
5. **配置监控**：监控配置访问和修改，记录审计日志
6. **配置更新**：安全地更新配置，验证更新的有效性
7. **配置备份**：定期备份配置，确保数据安全
8. **配置恢复**：在需要时安全地恢复配置

### 9.3 安全编码指南

- **避免硬编码敏感信息**：不要在代码中硬编码密码、密钥等敏感信息
- **使用强加密算法**：使用经过验证的强加密算法，如 AES-256
- **安全地管理密钥**：使用密钥管理系统或安全存储管理加密密钥
- **验证用户输入**：验证所有用户输入，防止注入攻击
- **使用安全的默认值**：为配置提供安全的默认值
- **实现最小权限**：只授予必要的最小权限
- **记录安全事件**：记录所有安全相关事件，如访问拒绝、验证失败等
- **定期安全审查**：定期审查配置系统的安全性

## 10. 常见问题和解决方案

### 10.1 如何保护配置文件中的敏感信息？

**问题**：配置文件中包含敏感信息，如何保护这些信息？

**解决方案**：
- 使用属性级加密，只加密敏感属性
- 使用安全存储提供程序存储敏感信息，在配置文件中使用占位符
- 实现访问控制，限制对敏感配置的访问
- 使用环境变量或安全的配置提供程序存储敏感信息

### 10.2 如何防止未授权访问配置？

**问题**：如何防止未授权用户访问配置？

**解决方案**：
- 实现基于角色的访问控制
- 使用安全代理控制对配置的访问
- 记录所有配置访问和修改操作
- 实现最小权限原则，只授予必要的最小权限

### 10.3 如何安全地传输配置？

**问题**：如何在网络传输过程中保护配置数据？

**解决方案**：
- 使用 TLS/SSL 加密传输
- 实现配置传输加密和签名
- 验证配置数据的完整性和真实性
- 使用安全的传输协议，如 HTTPS

### 10.4 如何处理配置文件损坏或丢失？

**问题**：如何处理配置文件损坏或丢失的情况？

**解决方案**：
- 实现配置备份和恢复机制
- 使用默认值初始化配置
- 实现配置验证，检测损坏的配置
- 记录配置更改，支持回滚到先前的配置

### 10.5 如何安全地更新配置？

**问题**：如何安全地更新配置？

**解决方案**：
- 验证配置更新的有效性和安全性
- 记录配置更新操作
- 实现配置版本控制，支持回滚
- 使用安全的更新机制，如事务更新

## 11. 总结

本文档提供了 Pek.Common 配置系统的安全性最佳实践和实现指南。通过实现敏感数据加密、访问控制、安全存储、安全传输、审计和日志记录、配置验证和安全默认值，可以显著提高配置系统的安全性。

安全是一个持续的过程，应该根据应用程序的具体需求和使用场景进行针对性的安全措施。通过遵循本文档中的最佳实践和解决方案，可以确保配置系统在各种环境和负载下都能安全运行。