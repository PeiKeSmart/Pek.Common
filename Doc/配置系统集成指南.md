# Pek.Common 配置系统集成指南

## 1. 简介

本文档提供了 Pek.Common 配置系统与其他框架和系统集成的指南和最佳实践。通过将配置系统集成到现有的应用程序架构中，可以实现统一的配置管理，提高应用程序的可维护性和灵活性。

### 1.1 集成目标

配置系统的集成应该关注以下方面：

- 与现有框架的无缝集成
- 保持配置系统的独立性和可测试性
- 支持不同的应用程序架构
- 提供统一的配置访问接口
- 保持配置的一致性和可靠性

## 2. 与依赖注入框架集成

### 2.1 Microsoft.Extensions.DependencyInjection 集成

```csharp
public static class ConfigServiceCollectionExtensions
{
    public static IServiceCollection AddConfig<TConfig>(this IServiceCollection services, Action<ConfigOptions<TConfig>> configureOptions = null)
        where TConfig : class, new()
    {
        var options = new ConfigOptions<TConfig>();
        configureOptions?.Invoke(options);
        
        // 注册配置管理器
        services.AddSingleton<Config<TConfig>>(serviceProvider =>
        {
            string configPath = options.ConfigPath ?? GetDefaultConfigPath<TConfig>();
            var config = new Config<TConfig>();
            
            if (options.AutoLoad)
            {
                config.Load();
            }
            
            return config;
        });
        
        // 注册配置实例
        services.AddSingleton<TConfig>(serviceProvider =>
        {
            var config = serviceProvider.GetRequiredService<Config<TConfig>>();
            return config.Current;
        });
        
        return services;
    }
    
    private static string GetDefaultConfigPath<TConfig>() where TConfig : class, new()
    {
        string baseDir = AppDomain.CurrentDomain.BaseDirectory;
        string configDir = Path.Combine(baseDir, "Config");
        string configFileName = $"{typeof(TConfig).Name}.json";
        return Path.Combine(configDir, configFileName);
    }
}

public class ConfigOptions<TConfig> where TConfig : class, new()
{
    public string ConfigPath { get; set; }
    public bool AutoLoad { get; set; } = true;
}
```

使用示例：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<AppSettings>(options =>
        {
            options.ConfigPath = "Config/appsettings.json";
            options.AutoLoad = true;
        });
        
        // 添加其他服务
        services.AddControllers();
    }
}

public class AppController : Controller
{
    private readonly AppSettings _settings;
    private readonly Config<AppSettings> _config;
    
    public AppController(AppSettings settings, Config<AppSettings> config)
    {
        _settings = settings;
        _config = config;
    }
    
    public IActionResult Index()
    {
        // 使用配置
        return View(new { AppName = _settings.AppName });
    }
    
    public IActionResult UpdateSettings(string appName)
    {
        // 更新配置
        _config.Current.AppName = appName;
        _config.Save();
        
        return RedirectToAction("Index");
    }
}
```

### 2.2 Autofac 集成

```csharp
public static class ConfigAutofacExtensions
{
    public static ContainerBuilder AddConfig<TConfig>(this ContainerBuilder builder, Action<ConfigOptions<TConfig>> configureOptions = null)
        where TConfig : class, new()
    {
        var options = new ConfigOptions<TConfig>();
        configureOptions?.Invoke(options);
        
        // 注册配置管理器
        builder.Register(c =>
        {
            string configPath = options.ConfigPath ?? GetDefaultConfigPath<TConfig>();
            var config = new Config<TConfig>();
            
            if (options.AutoLoad)
            {
                config.Load();
            }
            
            return config;
        }).SingleInstance();
        
        // 注册配置实例
        builder.Register(c =>
        {
            var config = c.Resolve<Config<TConfig>>();
            return config.Current;
        }).SingleInstance();
        
        return builder;
    }
    
    private static string GetDefaultConfigPath<TConfig>() where TConfig : class, new()
    {
        string baseDir = AppDomain.CurrentDomain.BaseDirectory;
        string configDir = Path.Combine(baseDir, "Config");
        string configFileName = $"{typeof(TConfig).Name}.json";
        return Path.Combine(configDir, configFileName);
    }
}
```

使用示例：

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        var builder = new ContainerBuilder();
        
        // 添加配置
        builder.AddConfig<AppSettings>(options =>
        {
            options.ConfigPath = "Config/appsettings.json";
            options.AutoLoad = true;
        });
        
        // 添加其他服务
        builder.RegisterType<AppService>().As<IAppService>();
        
        var container = builder.Build();
        
        // 使用容器
        using (var scope = container.BeginLifetimeScope())
        {
            var appService = scope.Resolve<IAppService>();
            appService.Run();
        }
    }
}
```

## 3. 与配置框架集成

### 3.1 Microsoft.Extensions.Configuration 集成

```csharp
public static class ConfigExtensions
{
    public static IConfigurationBuilder AddPekConfig<TConfig>(this IConfigurationBuilder builder, string configPath = null)
        where TConfig : class, new()
    {
        configPath = configPath ?? GetDefaultConfigPath<TConfig>();
        
        var config = new Config<TConfig>();
        config.Load();
        
        var configDictionary = ConvertToDictionary(config.Current);
        var memorySource = new MemoryConfigurationSource
        {
            InitialData = configDictionary
        };
        
        builder.Add(memorySource);
        
        return builder;
    }
    
    private static Dictionary<string, string> ConvertToDictionary<TConfig>(TConfig config) where TConfig : class, new()
    {
        var result = new Dictionary<string, string>();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            object value = property.GetValue(config);
            if (value != null)
            {
                result[property.Name] = value.ToString();
            }
        }
        
        return result;
    }
    
    private static string GetDefaultConfigPath<TConfig>() where TConfig : class, new()
    {
        string baseDir = AppDomain.CurrentDomain.BaseDirectory;
        string configDir = Path.Combine(baseDir, "Config");
        string configFileName = $"{typeof(TConfig).Name}.json";
        return Path.Combine(configDir, configFileName);
    }
}
```

使用示例：

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        var configuration = new ConfigurationBuilder()
            .AddPekConfig<AppSettings>()
            .AddJsonFile("appsettings.json", optional: true)
            .AddEnvironmentVariables()
            .Build();
        
        // 使用配置
        string appName = configuration["AppName"];
        Console.WriteLine($"App Name: {appName}");
    }
}
```

### 3.2 自定义配置提供程序

```csharp
public class PekConfigurationProvider : ConfigurationProvider
{
    private readonly Type _configType;
    private readonly string _configPath;
    
    public PekConfigurationProvider(Type configType, string configPath = null)
    {
        _configType = configType;
        _configPath = configPath;
    }
    
    public override void Load()
    {
        // 创建配置实例
        var configManagerType = typeof(Config<>).MakeGenericType(_configType);
        var configManager = Activator.CreateInstance(configManagerType);
        
        // 加载配置
        var loadMethod = configManagerType.GetMethod("Load");
        loadMethod.Invoke(configManager, null);
        
        // 获取配置实例
        var currentProperty = configManagerType.GetProperty("Current");
        var config = currentProperty.GetValue(configManager);
        
        // 转换为字典
        Data = ConvertToDictionary(config);
    }
    
    private Dictionary<string, string> ConvertToDictionary(object config)
    {
        var result = new Dictionary<string, string>();
        Type configType = config.GetType();
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            object value = property.GetValue(config);
            if (value != null)
            {
                result[property.Name] = value.ToString();
            }
        }
        
        return result;
    }
}

public class PekConfigurationSource : IConfigurationSource
{
    private readonly Type _configType;
    private readonly string _configPath;
    
    public PekConfigurationSource(Type configType, string configPath = null)
    {
        _configType = configType;
        _configPath = configPath;
    }
    
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new PekConfigurationProvider(_configType, _configPath);
    }
}

public static class PekConfigurationExtensions
{
    public static IConfigurationBuilder AddPekConfig<TConfig>(this IConfigurationBuilder builder, string configPath = null)
        where TConfig : class, new()
    {
        return builder.Add(new PekConfigurationSource(typeof(TConfig), configPath));
    }
}
```

## 4. 与 Web 框架集成

### 4.1 ASP.NET Core 集成

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<AppSettings>(options =>
        {
            options.ConfigPath = "Config/appsettings.json";
            options.AutoLoad = true;
        });
        
        // 添加其他服务
        services.AddControllers();
    }
    
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        
        app.UseRouting();
        
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

### 4.2 配置中间件

```csharp
public class ConfigMiddleware
{
    private readonly RequestDelegate _next;
    
    public ConfigMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    
    public async Task InvokeAsync(HttpContext context, Config<AppSettings> config)
    {
        // 在请求处理前访问配置
        var appSettings = config.Current;
        
        // 继续处理请求
        await _next(context);
        
        // 在请求处理后访问配置
    }
}

public static class ConfigMiddlewareExtensions
{
    public static IApplicationBuilder UseConfig(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<ConfigMiddleware>();
    }
}
```

使用示例：

```csharp
public class Startup
{
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // 使用配置中间件
        app.UseConfig();
        
        // 其他中间件
        app.UseRouting();
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

## 5. 与数据访问层集成

### 5.1 Entity Framework Core 集成

```csharp
public class AppDbContext : DbContext
{
    private readonly DatabaseSettings _settings;
    
    public AppDbContext(DatabaseSettings settings)
    {
        _settings = settings;
    }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.UseSqlServer(_settings.ConnectionString);
        }
    }
    
    // 定义实体集
    public DbSet<User> Users { get; set; }
    public DbSet<Product> Products { get; set; }
}

public class DatabaseSettings
{
    public string ConnectionString { get; set; } = "Server=localhost;Database=AppDb;Trusted_Connection=True;";
    public int CommandTimeout { get; set; } = 30;
    public bool EnableSensitiveDataLogging { get; set; } = false;
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<DatabaseSettings>(options =>
        {
            options.ConfigPath = "Config/database.json";
            options.AutoLoad = true;
        });
        
        // 添加 DbContext
        services.AddDbContext<AppDbContext>((serviceProvider, options) =>
        {
            var settings = serviceProvider.GetRequiredService<DatabaseSettings>();
            options.UseSqlServer(settings.ConnectionString, sqlOptions =>
            {
                sqlOptions.CommandTimeout(settings.CommandTimeout);
            });
            
            if (settings.EnableSensitiveDataLogging)
            {
                options.EnableSensitiveDataLogging();
            }
        });
    }
}
```

### 5.2 Dapper 集成

```csharp
public class DapperRepository
{
    private readonly DatabaseSettings _settings;
    private readonly IDbConnection _connection;
    
    public DapperRepository(DatabaseSettings settings)
    {
        _settings = settings;
        _connection = new SqlConnection(_settings.ConnectionString);
    }
    
    public async Task<IEnumerable<T>> QueryAsync<T>(string sql, object param = null)
    {
        return await _connection.QueryAsync<T>(sql, param, commandTimeout: _settings.CommandTimeout);
    }
    
    public async Task<int> ExecuteAsync(string sql, object param = null)
    {
        return await _connection.ExecuteAsync(sql, param, commandTimeout: _settings.CommandTimeout);
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<DatabaseSettings>(options =>
        {
            options.ConfigPath = "Config/database.json";
            options.AutoLoad = true;
        });
        
        // 添加 Dapper 仓储
        services.AddScoped<DapperRepository>();
    }
}
```

## 6. 与日志框架集成

### 6.1 Serilog 集成

```csharp
public class LogSettings
{
    public string MinimumLevel { get; set; } = "Information";
    public string FilePath { get; set; } = "Logs/app.log";
    public bool ConsoleEnabled { get; set; } = true;
    public int RetainedFileCountLimit { get; set; } = 31;
    public string RollingInterval { get; set; } = "Day";
}

public static class LoggingExtensions
{
    public static LoggerConfiguration ConfigureFromSettings(this LoggerConfiguration loggerConfiguration, LogSettings settings)
    {
        // 设置最小日志级别
        LogEventLevel minimumLevel = Enum.Parse<LogEventLevel>(settings.MinimumLevel, true);
        loggerConfiguration.MinimumLevel.Is(minimumLevel);
        
        // 添加控制台接收器
        if (settings.ConsoleEnabled)
        {
            loggerConfiguration.WriteTo.Console();
        }
        
        // 添加文件接收器
        if (!string.IsNullOrEmpty(settings.FilePath))
        {
            RollingInterval rollingInterval = Enum.Parse<RollingInterval>(settings.RollingInterval, true);
            
            loggerConfiguration.WriteTo.File(
                settings.FilePath,
                rollingInterval: rollingInterval,
                retainedFileCountLimit: settings.RetainedFileCountLimit);
        }
        
        return loggerConfiguration;
    }
}
```

使用示例：

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        // 加载日志配置
        var logConfig = new Config<LogSettings>();
        logConfig.Load();
        
        // 配置 Serilog
        Log.Logger = new LoggerConfiguration()
            .ConfigureFromSettings(logConfig.Current)
            .CreateLogger();
        
        try
        {
            Log.Information("Starting application");
            CreateHostBuilder(args).Build().Run();
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, "Application terminated unexpectedly");
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .UseSerilog()
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

### 6.2 NLog 集成

```csharp
public class NLogConfigProvider
{
    private readonly LogSettings _settings;
    
    public NLogConfigProvider(LogSettings settings)
    {
        _settings = settings;
    }
    
    public void Configure()
    {
        var config = new LoggingConfiguration();
        
        // 添加控制台目标
        if (_settings.ConsoleEnabled)
        {
            var consoleTarget = new ColoredConsoleTarget("console")
            {
                Layout = "${longdate}|${level:uppercase=true}|${logger}|${message}${exception:format=tostring}"
            };
            
            config.AddTarget(consoleTarget);
            config.AddRule(LogLevel.FromString(_settings.MinimumLevel), LogLevel.Fatal, consoleTarget);
        }
        
        // 添加文件目标
        if (!string.IsNullOrEmpty(_settings.FilePath))
        {
            var fileTarget = new FileTarget("file")
            {
                FileName = _settings.FilePath,
                Layout = "${longdate}|${level:uppercase=true}|${logger}|${message}${exception:format=tostring}",
                ArchiveNumbering = ArchiveNumberingMode.Date,
                ArchiveEvery = FileArchivePeriod.Day,
                MaxArchiveFiles = _settings.RetainedFileCountLimit
            };
            
            config.AddTarget(fileTarget);
            config.AddRule(LogLevel.FromString(_settings.MinimumLevel), LogLevel.Fatal, fileTarget);
        }
        
        // 应用配置
        LogManager.Configuration = config;
    }
}
```

使用示例：

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        // 加载日志配置
        var logConfig = new Config<LogSettings>();
        logConfig.Load();
        
        // 配置 NLog
        var nlogConfigProvider = new NLogConfigProvider(logConfig.Current);
        nlogConfigProvider.Configure();
        
        try
        {
            var logger = LogManager.GetCurrentClassLogger();
            logger.Info("Starting application");
            CreateHostBuilder(args).Build().Run();
        }
        catch (Exception ex)
        {
            LogManager.GetCurrentClassLogger().Fatal(ex, "Application terminated unexpectedly");
        }
        finally
        {
            LogManager.Shutdown();
        }
    }
    
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.ClearProviders();
                logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Trace);
            })
            .UseNLog()
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
```

## 7. 与消息队列集成

### 7.1 RabbitMQ 集成

```csharp
public class RabbitMQSettings
{
    public string HostName { get; set; } = "localhost";
    public int Port { get; set; } = 5672;
    public string UserName { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";
    public bool AutomaticRecoveryEnabled { get; set; } = true;
    public int NetworkRecoveryInterval { get; set; } = 10;
}

public class RabbitMQService
{
    private readonly RabbitMQSettings _settings;
    private readonly IConnection _connection;
    private readonly IModel _channel;
    
    public RabbitMQService(RabbitMQSettings settings)
    {
        _settings = settings;
        
        var factory = new ConnectionFactory
        {
            HostName = _settings.HostName,
            Port = _settings.Port,
            UserName = _settings.UserName,
            Password = _settings.Password,
            VirtualHost = _settings.VirtualHost,
            AutomaticRecoveryEnabled = _settings.AutomaticRecoveryEnabled,
            NetworkRecoveryInterval = TimeSpan.FromSeconds(_settings.NetworkRecoveryInterval)
        };
        
        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();
    }
    
    public void PublishMessage(string exchange, string routingKey, string message)
    {
        var body = Encoding.UTF8.GetBytes(message);
        
        _channel.BasicPublish(
            exchange: exchange,
            routingKey: routingKey,
            basicProperties: null,
            body: body);
    }
    
    public void Dispose()
    {
        _channel?.Dispose();
        _connection?.Dispose();
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<RabbitMQSettings>(options =>
        {
            options.ConfigPath = "Config/rabbitmq.json";
            options.AutoLoad = true;
        });
        
        // 添加 RabbitMQ 服务
        services.AddSingleton<RabbitMQService>();
    }
}
```

### 7.2 Kafka 集成

```csharp
public class KafkaSettings
{
    public string BootstrapServers { get; set; } = "localhost:9092";
    public string GroupId { get; set; } = "app-consumer-group";
    public bool EnableAutoCommit { get; set; } = true;
    public int AutoCommitIntervalMs { get; set; } = 5000;
    public string AutoOffsetReset { get; set; } = "earliest";
}

public class KafkaProducerService
{
    private readonly KafkaSettings _settings;
    private readonly IProducer<Null, string> _producer;
    
    public KafkaProducerService(KafkaSettings settings)
    {
        _settings = settings;
        
        var config = new ProducerConfig
        {
            BootstrapServers = _settings.BootstrapServers
        };
        
        _producer = new ProducerBuilder<Null, string>(config).Build();
    }
    
    public async Task ProduceAsync(string topic, string message)
    {
        await _producer.ProduceAsync(topic, new Message<Null, string> { Value = message });
    }
    
    public void Dispose()
    {
        _producer?.Dispose();
    }
}

public class KafkaConsumerService
{
    private readonly KafkaSettings _settings;
    private readonly IConsumer<Null, string> _consumer;
    
    public KafkaConsumerService(KafkaSettings settings)
    {
        _settings = settings;
        
        var config = new ConsumerConfig
        {
            BootstrapServers = _settings.BootstrapServers,
            GroupId = _settings.GroupId,
            EnableAutoCommit = _settings.EnableAutoCommit,
            AutoCommitIntervalMs = _settings.AutoCommitIntervalMs,
            AutoOffsetReset = Enum.Parse<AutoOffsetReset>(_settings.AutoOffsetReset, true)
        };
        
        _consumer = new ConsumerBuilder<Null, string>(config).Build();
    }
    
    public void Subscribe(string topic)
    {
        _consumer.Subscribe(topic);
    }
    
    public ConsumeResult<Null, string> Consume(CancellationToken cancellationToken = default)
    {
        return _consumer.Consume(cancellationToken);
    }
    
    public void Dispose()
    {
        _consumer?.Dispose();
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<KafkaSettings>(options =>
        {
            options.ConfigPath = "Config/kafka.json";
            options.AutoLoad = true;
        });
        
        // 添加 Kafka 服务
        services.AddSingleton<KafkaProducerService>();
        services.AddSingleton<KafkaConsumerService>();
    }
}
```

## 8. 与缓存系统集成

### 8.1 Redis 集成

```csharp
public class RedisSettings
{
    public string ConnectionString { get; set; } = "localhost:6379";
    public string InstanceName { get; set; } = "AppInstance";
    public int DefaultDatabase { get; set; } = 0;
    public int ConnectTimeout { get; set; } = 5000;
    public int SyncTimeout { get; set; } = 5000;
}

public class RedisService
{
    private readonly RedisSettings _settings;
    private readonly ConnectionMultiplexer _connection;
    private readonly IDatabase _database;
    
    public RedisService(RedisSettings settings)
    {
        _settings = settings;
        
        var options = ConfigurationOptions.Parse(_settings.ConnectionString);
        options.DefaultDatabase = _settings.DefaultDatabase;
        options.ConnectTimeout = _settings.ConnectTimeout;
        options.SyncTimeout = _settings.SyncTimeout;
        
        _connection = ConnectionMultiplexer.Connect(options);
        _database = _connection.GetDatabase();
    }
    
    public async Task<bool> SetAsync(string key, string value, TimeSpan? expiry = null)
    {
        return await _database.StringSetAsync(key, value, expiry);
    }
    
    public async Task<string> GetAsync(string key)
    {
        return await _database.StringGetAsync(key);
    }
    
    public async Task<bool> DeleteAsync(string key)
    {
        return await _database.KeyDeleteAsync(key);
    }
    
    public void Dispose()
    {
        _connection?.Dispose();
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<RedisSettings>(options =>
        {
            options.ConfigPath = "Config/redis.json";
            options.AutoLoad = true;
        });
        
        // 添加 Redis 服务
        services.AddSingleton<RedisService>();
        
        // 添加分布式缓存
        services.AddStackExchangeRedisCache(options =>
        {
            var redisSettings = services.BuildServiceProvider().GetRequiredService<RedisSettings>();
            options.Configuration = redisSettings.ConnectionString;
            options.InstanceName = redisSettings.InstanceName;
        });
    }
}
```

### 8.2 内存缓存集成

```csharp
public class CacheSettings
{
    public int AbsoluteExpirationMinutes { get; set; } = 60;
    public int SlidingExpirationMinutes { get; set; } = 20;
    public long SizeLimit { get; set; } = 1024;
}

public class CacheService
{
    private readonly CacheSettings _settings;
    private readonly IMemoryCache _cache;
    
    public CacheService(CacheSettings settings, IMemoryCache cache)
    {
        _settings = settings;
        _cache = cache;
    }
    
    public void Set<T>(string key, T value, TimeSpan? absoluteExpiration = null, TimeSpan? slidingExpiration = null)
    {
        var options = new MemoryCacheEntryOptions();
        
        if (absoluteExpiration.HasValue)
        {
            options.AbsoluteExpirationRelativeToNow = absoluteExpiration.Value;
        }
        else
        {
            options.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(_settings.AbsoluteExpirationMinutes);
        }
        
        if (slidingExpiration.HasValue)
        {
            options.SlidingExpiration = slidingExpiration.Value;
        }
        else
        {
            options.SlidingExpiration = TimeSpan.FromMinutes(_settings.SlidingExpirationMinutes);
        }
        
        _cache.Set(key, value, options);
    }
    
    public bool TryGetValue<T>(string key, out T value)
    {
        return _cache.TryGetValue(key, out value);
    }
    
    public void Remove(string key)
    {
        _cache.Remove(key);
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<CacheSettings>(options =>
        {
            options.ConfigPath = "Config/cache.json";
            options.AutoLoad = true;
        });
        
        // 添加内存缓存
        services.AddMemoryCache(options =>
        {
            var cacheSettings = services.BuildServiceProvider().GetRequiredService<CacheSettings>();
            options.SizeLimit = cacheSettings.SizeLimit;
        });
        
        // 添加缓存服务
        services.AddSingleton<CacheService>();
    }
}
```

## 9. 与身份验证系统集成

### 9.1 JWT 身份验证集成

```csharp
public class JwtSettings
{
    public string Secret { get; set; } = "your-secret-key-with-at-least-16-characters";
    public string Issuer { get; set; } = "your-issuer";
    public string Audience { get; set; } = "your-audience";
    public int ExpirationMinutes { get; set; } = 60;
}

public class JwtService
{
    private readonly JwtSettings _settings;
    
    public JwtService(JwtSettings settings)
    {
        _settings = settings;
    }
    
    public string GenerateToken(string userId, string userName, IEnumerable<string> roles)
    {
        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, userId),
            new Claim(ClaimTypes.Name, userName)
        };
        
        foreach (var role in roles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role));
        }
        
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.Secret));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _settings.Issuer,
            audience: _settings.Audience,
            claims: claims,
            expires: DateTime.Now.AddMinutes(_settings.ExpirationMinutes),
            signingCredentials: creds);
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
    
    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.Secret));
        
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = _settings.Issuer,
            ValidAudience = _settings.Audience,
            IssuerSigningKey = key
        };
        
        return tokenHandler.ValidateToken(token, validationParameters, out _);
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<JwtSettings>(options =>
        {
            options.ConfigPath = "Config/jwt.json";
            options.AutoLoad = true;
        });
        
        // 添加 JWT 服务
        services.AddSingleton<JwtService>();
        
        // 添加 JWT 身份验证
        var serviceProvider = services.BuildServiceProvider();
        var jwtSettings = serviceProvider.GetRequiredService<JwtSettings>();
        
        services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = jwtSettings.Issuer,
                    ValidAudience = jwtSettings.Audience,
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.Secret))
                };
            });
    }
}
```

### 9.2 Identity 集成

```csharp
public class IdentitySettings
{
    public bool RequireUniqueEmail { get; set; } = true;
    public int PasswordRequiredLength { get; set; } = 8;
    public bool PasswordRequireDigit { get; set; } = true;
    public bool PasswordRequireLowercase { get; set; } = true;
    public bool PasswordRequireUppercase { get; set; } = true;
    public bool PasswordRequireNonAlphanumeric { get; set; } = true;
    public int LockoutMaxFailedAttempts { get; set; } = 5;
    public int LockoutDefaultLockoutMinutes { get; set; } = 5;
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<IdentitySettings>(options =>
        {
            options.ConfigPath = "Config/identity.json";
            options.AutoLoad = true;
        });
        
        // 添加 Identity
        var serviceProvider = services.BuildServiceProvider();
        var identitySettings = serviceProvider.GetRequiredService<IdentitySettings>();
        
        services.AddIdentity<ApplicationUser, IdentityRole>(options =>
        {
            // 密码设置
            options.Password.RequiredLength = identitySettings.PasswordRequiredLength;
            options.Password.RequireDigit = identitySettings.PasswordRequireDigit;
            options.Password.RequireLowercase = identitySettings.PasswordRequireLowercase;
            options.Password.RequireUppercase = identitySettings.PasswordRequireUppercase;
            options.Password.RequireNonAlphanumeric = identitySettings.PasswordRequireNonAlphanumeric;
            
            // 用户设置
            options.User.RequireUniqueEmail = identitySettings.RequireUniqueEmail;
            
            // 锁定设置
            options.Lockout.MaxFailedAccessAttempts = identitySettings.LockoutMaxFailedAttempts;
            options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(identitySettings.LockoutDefaultLockoutMinutes);
        })
        .AddEntityFrameworkStores<AppDbContext>()
        .AddDefaultTokenProviders();
    }
}
```

## 10. 与后台服务集成

### 10.1 后台服务集成

```csharp
public class BackgroundServiceSettings
{
    public bool Enabled { get; set; } = true;
    public int IntervalSeconds { get; set; } = 60;
    public int MaxRetryCount { get; set; } = 3;
    public int RetryDelaySeconds { get; set; } = 5;
}

public class SampleBackgroundService : BackgroundService
{
    private readonly BackgroundServiceSettings _settings;
    private readonly ILogger<SampleBackgroundService> _logger;
    
    public SampleBackgroundService(Config<BackgroundServiceSettings> config, ILogger<SampleBackgroundService> logger)
    {
        _settings = config.Current;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (!_settings.Enabled)
        {
            _logger.LogInformation("Background service is disabled");
            return;
        }
        
        _logger.LogInformation("Background service is starting");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                _logger.LogInformation("Executing background task");
                await DoWorkAsync(stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred while executing background task");
                
                // 重试逻辑
                for (int i = 0; i < _settings.MaxRetryCount; i++)
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromSeconds(_settings.RetryDelaySeconds), stoppingToken);
                        _logger.LogInformation("Retrying background task ({RetryCount}/{MaxRetryCount})", i + 1, _settings.MaxRetryCount);
                        await DoWorkAsync(stoppingToken);
                        break;
                    }
                    catch (Exception retryEx)
                    {
                        _logger.LogError(retryEx, "Error occurred while retrying background task ({RetryCount}/{MaxRetryCount})", i + 1, _settings.MaxRetryCount);
                    }
                }
            }
            
            await Task.Delay(TimeSpan.FromSeconds(_settings.IntervalSeconds), stoppingToken);
        }
        
        _logger.LogInformation("Background service is stopping");
    }
    
    private async Task DoWorkAsync(CancellationToken stoppingToken)
    {
        // 执行后台任务
        await Task.CompletedTask;
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<BackgroundServiceSettings>(options =>
        {
            options.ConfigPath = "Config/backgroundService.json";
            options.AutoLoad = true;
        });
        
        // 添加后台服务
        services.AddHostedService<SampleBackgroundService>();
    }
}
```

### 10.2 定时任务集成

```csharp
public class ScheduledTaskSettings
{
    public bool Enabled { get; set; } = true;
    public string CronExpression { get; set; } = "0 0 * * *"; // 每天 0 点执行
    public int MaxRetryCount { get; set; } = 3;
    public int RetryDelaySeconds { get; set; } = 5;
}

public class ScheduledTaskService : BackgroundService
{
    private readonly ScheduledTaskSettings _settings;
    private readonly ILogger<ScheduledTaskService> _logger;
    
    public ScheduledTaskService(Config<ScheduledTaskSettings> config, ILogger<ScheduledTaskService> logger)
    {
        _settings = config.Current;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (!_settings.Enabled)
        {
            _logger.LogInformation("Scheduled task service is disabled");
            return;
        }
        
        _logger.LogInformation("Scheduled task service is starting");
        
        var cronExpression = CronExpression.Parse(_settings.CronExpression);
        var nextRun = cronExpression.GetNextOccurrence(DateTimeOffset.Now);
        
        while (!stoppingToken.IsCancellationRequested)
        {
            if (nextRun.HasValue)
            {
                var delay = nextRun.Value - DateTimeOffset.Now;
                if (delay > TimeSpan.Zero)
                {
                    await Task.Delay(delay, stoppingToken);
                }
                
                try
                {
                    _logger.LogInformation("Executing scheduled task");
                    await DoWorkAsync(stoppingToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error occurred while executing scheduled task");
                    
                    // 重试逻辑
                    for (int i = 0; i < _settings.MaxRetryCount; i++)
                    {
                        try
                        {
                            await Task.Delay(TimeSpan.FromSeconds(_settings.RetryDelaySeconds), stoppingToken);
                            _logger.LogInformation("Retrying scheduled task ({RetryCount}/{MaxRetryCount})", i + 1, _settings.MaxRetryCount);
                            await DoWorkAsync(stoppingToken);
                            break;
                        }
                        catch (Exception retryEx)
                        {
                            _logger.LogError(retryEx, "Error occurred while retrying scheduled task ({RetryCount}/{MaxRetryCount})", i + 1, _settings.MaxRetryCount);
                        }
                    }
                }
                
                nextRun = cronExpression.GetNextOccurrence(DateTimeOffset.Now);
            }
            else
            {
                await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
            }
        }
        
        _logger.LogInformation("Scheduled task service is stopping");
    }
    
    private async Task DoWorkAsync(CancellationToken stoppingToken)
    {
        // 执行定时任务
        await Task.CompletedTask;
    }
}
```

注册服务：

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 添加配置
        services.AddConfig<ScheduledTaskSettings>(options =>
        {
            options.ConfigPath = "Config/scheduledTask.json";
            options.AutoLoad = true;
        });
        
        // 添加定时任务服务
        services.AddHostedService<ScheduledTaskService>();
    }
}
```

## 11. 集成最佳实践

### 11.1 集成设计原则

- **单一职责原则**：每个集成组件应该只负责一个功能
- **开闭原则**：集成应该对修改关闭，对扩展开放
- **接口隔离原则**：使用小而专注的接口，而不是大而全的接口
- **依赖倒置原则**：依赖抽象，而不是具体实现
- **组合优于继承**：使用组合而不是继承来扩展功能

### 11.2 集成实现指南

1. **使用依赖注入**：使用依赖注入容器管理配置和服务
2. **配置分离**：将不同组件的配置分离到不同的配置类中
3. **接口抽象**：使用接口抽象集成组件，便于替换和测试
4. **延迟加载**：使用延迟加载避免不必要的配置加载
5. **配置验证**：验证配置的有效性，避免运行时错误
6. **错误处理**：处理配置加载和使用过程中的错误
7. **监控和日志**：记录配置的使用情况和错误

### 11.3 集成示例

```csharp
public class IntegrationExample
{
    public static void Run()
    {
        // 创建服务集合
        var services = new ServiceCollection();
        
        // 添加配置
        services.AddConfig<AppSettings>(options =>
        {
            options.ConfigPath = "Config/appsettings.json";
            options.AutoLoad = true;
        });
        
        services.AddConfig<DatabaseSettings>(options =>
        {
            options.ConfigPath = "Config/database.json";
            options.AutoLoad = true;
        });
        
        services.AddConfig<LogSettings>(options =>
        {
            options.ConfigPath = "Config/log.json";
            options.AutoLoad = true;
        });
        
        // 添加日志服务
        services.AddLogging(builder =>
        {
            var serviceProvider = services.BuildServiceProvider();
            var logSettings = serviceProvider.GetRequiredService<LogSettings>();
            
            builder.AddConsole();
            builder.AddFile(logSettings.FilePath);
        });
        
        // 添加数据库服务
        services.AddDbContext<AppDbContext>((serviceProvider, options) =>
        {
            var dbSettings = serviceProvider.GetRequiredService<DatabaseSettings>();
            options.UseSqlServer(dbSettings.ConnectionString);
        });
        
        // 添加应用服务
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IProductService, ProductService>();
        
        // 创建服务提供程序
        var serviceProvider = services.BuildServiceProvider();
        
        // 使用服务
        var userService = serviceProvider.GetRequiredService<IUserService>();
        userService.CreateUser("john.doe@example.com", "John Doe");
    }
}
```

## 12. 常见问题和解决方案

### 12.1 如何处理配置变更？

**问题**：如何在配置变更时通知应用程序？

**解决方案**：
1. 实现配置变更通知机制
2. 使用观察者模式订阅配置变更事件
3. 在配置变更时重新加载相关服务

```csharp
public class ConfigChangeNotifier<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    
    public event EventHandler<ConfigChangeEventArgs<TConfig>> ConfigChanged;
    
    public ConfigChangeNotifier(Config<TConfig> config)
    {
        _config = config;
        
        // 监听配置文件变化
        string configPath = _config.FilePath;
        if (!string.IsNullOrEmpty(configPath) && File.Exists(configPath))
        {
            string directory = Path.GetDirectoryName(configPath);
            string fileName = Path.GetFileName(configPath);
            
            var watcher = new FileSystemWatcher(directory, fileName);
            watcher.Changed += OnConfigFileChanged;
            watcher.EnableRaisingEvents = true;
        }
    }
    
    private void OnConfigFileChanged(object sender, FileSystemEventArgs e)
    {
        // 重新加载配置
        TConfig oldConfig = _config.Current;
        _config.Load();
        TConfig newConfig = _config.Current;
        
        // 触发事件
        ConfigChanged?.Invoke(this, new ConfigChangeEventArgs<TConfig>(oldConfig, newConfig));
    }
}

public class ConfigChangeEventArgs<TConfig> : EventArgs where TConfig : class
{
    public TConfig OldConfig { get; }
    public TConfig NewConfig { get; }
    
    public ConfigChangeEventArgs(TConfig oldConfig, TConfig newConfig)
    {
        OldConfig = oldConfig;
        NewConfig = newConfig;
    }
}
```

### 12.2 如何处理配置依赖关系？

**问题**：如何处理配置之间的依赖关系？

**解决方案**：
1. 使用依赖注入容器管理配置依赖关系
2. 使用工厂模式创建依赖配置
3. 使用配置提供程序解析依赖

```csharp
public class ConfigDependencyResolver
{
    private readonly IServiceProvider _serviceProvider;
    
    public ConfigDependencyResolver(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public TConfig ResolveConfig<TConfig>() where TConfig : class, new()
    {
        return _serviceProvider.GetRequiredService<TConfig>();
    }
}
```

### 12.3 如何处理配置验证？

**问题**：如何验证配置的有效性？

**解决方案**：
1. 使用数据注解验证配置
2. 实现自定义验证逻辑
3. 在配置加载时验证配置

```csharp
public class ConfigValidator<TConfig> where TConfig : class, new()
{
    public ValidationResult Validate(TConfig config)
    {
        var validationResults = new List<ValidationResult>();
        var validationContext = new ValidationContext(config);
        
        bool isValid = Validator.TryValidateObject(config, validationContext, validationResults, true);
        
        return new ValidationResult
        {
            IsValid = isValid,
            Errors = validationResults
        };
    }
}

public class ValidationResult
{
    public bool IsValid { get; set; }
    public List<ValidationResult> Errors { get; set; } = new List<ValidationResult>();
}
```

### 12.4 如何处理配置加密？

**问题**：如何保护敏感配置信息？

**解决方案**：
1. 使用加密配置提供程序
2. 实现配置加密和解密
3. 使用安全存储提供程序

```csharp
public class EncryptedConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly Config<TConfig> _config;
    private readonly IEncryptionService _encryptionService;
    
    public EncryptedConfigProvider(Config<TConfig> config, IEncryptionService encryptionService)
    {
        _config = config;
        _encryptionService = encryptionService;
    }
    
    public TConfig GetConfig()
    {
        TConfig config = _config.Current;
        DecryptProperties(config);
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        EncryptProperties(config);
        _config.Current = config;
        _config.Save();
    }
    
    private void EncryptProperties(TConfig config)
    {
        // 加密敏感属性
    }
    
    private void DecryptProperties(TConfig config)
    {
        // 解密敏感属性
    }
}

public interface IEncryptionService
{
    string Encrypt(string plainText);
    string Decrypt(string cipherText);
}
```

### 12.5 如何处理多环境配置？

**问题**：如何支持不同环境的配置？

**解决方案**：
1. 使用环境特定的配置文件
2. 实现环境配置提供程序
3. 使用环境变量覆盖配置

```csharp
public class EnvironmentConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly string _environment;
    private readonly Dictionary<string, Config<TConfig>> _configs;
    
    public EnvironmentConfigProvider(string environment)
    {
        _environment = environment;
        _configs = new Dictionary<string, Config<TConfig>>();
    }
    
    public TConfig GetConfig()
    {
        // 尝试获取环境特定的配置
        if (_configs.TryGetValue(_environment, out Config<TConfig> config))
        {
            return config.Current;
        }
        
        // 尝试获取默认配置
        if (_configs.TryGetValue("Default", out config))
        {
            return config.Current;
        }
        
        // 返回新的配置实例
        return new TConfig();
    }
    
    public void AddConfig(string environment, Config<TConfig> config)
    {
        _configs[environment] = config;
    }
}
```

## 13. 总结

本文档提供了 Pek.Common 配置系统与其他框架和系统集成的指南和最佳实践。通过将配置系统集成到依赖注入框架、配置框架、Web 框架、数据访问层、日志框架、消息队列、缓存系统、身份验证系统和后台服务等，可以实现统一的配置管理，提高应用程序的可维护性和灵活性。

集成配置系统时，应该遵循集成设计原则，如单一职责原则、开闭原则、接口隔离原则、依赖倒置原则和组合优于继承原则。通过使用依赖注入、配置分离、接口抽象、延迟加载、配置验证、错误处理以及监控和日志等最佳实践，可以创建高质量的集成。

通过遵循本文档中的指南和最佳实践，可以将配置系统无缝集成到现有的应用程序架构中，满足各种应用场景的需求。