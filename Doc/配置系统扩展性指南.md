# Pek.Common 配置系统扩展性指南

## 1. 简介

本文档提供了 Pek.Common 配置系统的扩展性指南和最佳实践。配置系统的扩展性对于满足不同应用场景的需求至关重要，通过扩展配置系统，可以实现更多高级功能，如配置验证、配置变更通知、多环境支持等。

### 1.1 扩展目标

配置系统的扩展应该关注以下方面：

- 保持核心功能的简单性和稳定性
- 提供清晰的扩展点
- 支持插件式架构
- 保持向后兼容性
- 提供良好的文档和示例

## 2. 扩展点

### 2.1 配置提供程序

实现自定义配置提供程序，支持从不同来源加载配置：

```csharp
public interface IConfigProvider<TConfig> where TConfig : class, new()
{
    TConfig GetConfig();
    void SaveConfig(TConfig config);
}

// 文件配置提供程序（默认实现）
public class FileConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly string _filePath;
    private readonly JsonSerializerOptions _options;
    
    public FileConfigProvider(string filePath, JsonSerializerOptions options)
    {
        _filePath = filePath;
        _options = options;
    }
    
    public TConfig GetConfig()
    {
        if (!File.Exists(_filePath))
        {
            return new TConfig();
        }
        
        string json = File.ReadAllText(_filePath);
        return JsonSerializer.Deserialize<TConfig>(json, _options);
    }
    
    public void SaveConfig(TConfig config)
    {
        string directory = Path.GetDirectoryName(_filePath);
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        
        string json = JsonSerializer.Serialize(config, _options);
        File.WriteAllText(_filePath, json);
    }
}

// 环境变量配置提供程序
public class EnvironmentConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly string _prefix;
    private readonly JsonSerializerOptions _options;
    
    public EnvironmentConfigProvider(string prefix, JsonSerializerOptions options)
    {
        _prefix = prefix;
        _options = options;
    }
    
    public TConfig GetConfig()
    {
        TConfig config = new TConfig();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            string envVarName = $"{_prefix}_{property.Name}".ToUpper();
            string envVarValue = Environment.GetEnvironmentVariable(envVarName);
            
            if (!string.IsNullOrEmpty(envVarValue))
            {
                if (property.PropertyType == typeof(string))
                {
                    property.SetValue(config, envVarValue);
                }
                else if (property.PropertyType == typeof(int) && int.TryParse(envVarValue, out int intValue))
                {
                    property.SetValue(config, intValue);
                }
                else if (property.PropertyType == typeof(bool) && bool.TryParse(envVarValue, out bool boolValue))
                {
                    property.SetValue(config, boolValue);
                }
                else if (property.PropertyType == typeof(double) && double.TryParse(envVarValue, out double doubleValue))
                {
                    property.SetValue(config, doubleValue);
                }
            }
        }
        
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        // 环境变量配置提供程序通常是只读的，不支持保存
        throw new NotSupportedException("Environment variable config provider does not support saving.");
    }
}

// 内存配置提供程序
public class InMemoryConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private TConfig _config;
    
    public InMemoryConfigProvider(TConfig initialConfig = null)
    {
        _config = initialConfig ?? new TConfig();
    }
    
    public TConfig GetConfig()
    {
        return _config;
    }
    
    public void SaveConfig(TConfig config)
    {
        _config = config;
    }
}
```

### 2.2 配置序列化器

实现自定义配置序列化器，支持不同的序列化格式：

```csharp
public interface IConfigSerializer
{
    string Serialize<TConfig>(TConfig config);
    TConfig Deserialize<TConfig>(string serialized) where TConfig : class, new();
}

// JSON 序列化器（默认实现）
public class JsonConfigSerializer : IConfigSerializer
{
    private readonly JsonSerializerOptions _options;
    
    public JsonConfigSerializer(JsonSerializerOptions options = null)
    {
        _options = options ?? new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }
    
    public string Serialize<TConfig>(TConfig config)
    {
        return JsonSerializer.Serialize(config, _options);
    }
    
    public TConfig Deserialize<TConfig>(string serialized) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(serialized))
        {
            return new TConfig();
        }
        
        return JsonSerializer.Deserialize<TConfig>(serialized, _options);
    }
}

// XML 序列化器
public class XmlConfigSerializer : IConfigSerializer
{
    public string Serialize<TConfig>(TConfig config)
    {
        XmlSerializer serializer = new XmlSerializer(typeof(TConfig));
        using (StringWriter writer = new StringWriter())
        {
            serializer.Serialize(writer, config);
            return writer.ToString();
        }
    }
    
    public TConfig Deserialize<TConfig>(string serialized) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(serialized))
        {
            return new TConfig();
        }
        
        XmlSerializer serializer = new XmlSerializer(typeof(TConfig));
        using (StringReader reader = new StringReader(serialized))
        {
            return (TConfig)serializer.Deserialize(reader);
        }
    }
}

// YAML 序列化器（需要第三方库，如 YamlDotNet）
public class YamlConfigSerializer : IConfigSerializer
{
    private readonly ISerializer _serializer;
    private readonly IDeserializer _deserializer;
    
    public YamlConfigSerializer()
    {
        _serializer = new SerializerBuilder().Build();
        _deserializer = new DeserializerBuilder().Build();
    }
    
    public string Serialize<TConfig>(TConfig config)
    {
        return _serializer.Serialize(config);
    }
    
    public TConfig Deserialize<TConfig>(string serialized) where TConfig : class, new()
    {
        if (string.IsNullOrEmpty(serialized))
        {
            return new TConfig();
        }
        
        return _deserializer.Deserialize<TConfig>(serialized);
    }
}
```

### 2.3 配置验证器

实现配置验证器，验证配置的有效性：

```csharp
public interface IConfigValidator<TConfig> where TConfig : class
{
    ValidationResult Validate(TConfig config);
}

public class ValidationResult
{
    public bool IsValid => Errors.Count == 0;
    public Dictionary<string, List<string>> Errors { get; } = new Dictionary<string, List<string>>();
    
    public void AddError(string propertyName, string errorMessage)
    {
        if (!Errors.TryGetValue(propertyName, out List<string> propertyErrors))
        {
            propertyErrors = new List<string>();
            Errors[propertyName] = propertyErrors;
        }
        
        propertyErrors.Add(errorMessage);
    }
}

// 基于特性的验证器
public class AttributeConfigValidator<TConfig> : IConfigValidator<TConfig> where TConfig : class
{
    public ValidationResult Validate(TConfig config)
    {
        var result = new ValidationResult();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            ValidateProperty(config, property, result);
        }
        
        return result;
    }
    
    private void ValidateProperty(TConfig config, PropertyInfo property, ValidationResult result)
    {
        object value = property.GetValue(config);
        
        // 验证 Required
        if (property.GetCustomAttribute<RequiredAttribute>() != null)
        {
            if (value == null || (value is string str && string.IsNullOrWhiteSpace(str)))
            {
                result.AddError(property.Name, "This field is required.");
            }
        }
        
        // 验证 Range
        RangeAttribute rangeAttr = property.GetCustomAttribute<RangeAttribute>();
        if (rangeAttr != null && value != null)
        {
            if (value is int intValue)
            {
                if (intValue < rangeAttr.Minimum || intValue > rangeAttr.Maximum)
                {
                    result.AddError(property.Name, $"Value must be between {rangeAttr.Minimum} and {rangeAttr.Maximum}.");
                }
            }
            else if (value is double doubleValue)
            {
                if (doubleValue < rangeAttr.Minimum || doubleValue > rangeAttr.Maximum)
                {
                    result.AddError(property.Name, $"Value must be between {rangeAttr.Minimum} and {rangeAttr.Maximum}.");
                }
            }
        }
        
        // 验证 Regex
        RegexAttribute regexAttr = property.GetCustomAttribute<RegexAttribute>();
        if (regexAttr != null && value is string strValue && !string.IsNullOrEmpty(strValue))
        {
            if (!Regex.IsMatch(strValue, regexAttr.Pattern))
            {
                result.AddError(property.Name, "Value does not match the required pattern.");
            }
        }
    }
}

// 自定义验证器
public class CustomConfigValidator<TConfig> : IConfigValidator<TConfig> where TConfig : class
{
    private readonly Func<TConfig, ValidationResult> _validateFunc;
    
    public CustomConfigValidator(Func<TConfig, ValidationResult> validateFunc)
    {
        _validateFunc = validateFunc ?? throw new ArgumentNullException(nameof(validateFunc));
    }
    
    public ValidationResult Validate(TConfig config)
    {
        return _validateFunc(config);
    }
}
```

### 2.4 配置变更通知

实现配置变更通知，在配置变更时通知订阅者：

```csharp
public interface IConfigChangeNotifier<TConfig> where TConfig : class
{
    event EventHandler<ConfigChangeEventArgs<TConfig>> ConfigChanged;
    void NotifyConfigChanged(TConfig oldConfig, TConfig newConfig);
}

public class ConfigChangeEventArgs<TConfig> : EventArgs where TConfig : class
{
    public TConfig OldConfig { get; }
    public TConfig NewConfig { get; }
    public IReadOnlyDictionary<string, ConfigPropertyChange> Changes { get; }
    
    public ConfigChangeEventArgs(TConfig oldConfig, TConfig newConfig, IReadOnlyDictionary<string, ConfigPropertyChange> changes)
    {
        OldConfig = oldConfig;
        NewConfig = newConfig;
        Changes = changes;
    }
}

public class ConfigPropertyChange
{
    public string PropertyName { get; }
    public object OldValue { get; }
    public object NewValue { get; }
    
    public ConfigPropertyChange(string propertyName, object oldValue, object newValue)
    {
        PropertyName = propertyName;
        OldValue = oldValue;
        NewValue = newValue;
    }
}

public class ConfigChangeNotifier<TConfig> : IConfigChangeNotifier<TConfig> where TConfig : class
{
    public event EventHandler<ConfigChangeEventArgs<TConfig>> ConfigChanged;
    
    public void NotifyConfigChanged(TConfig oldConfig, TConfig newConfig)
    {
        if (ConfigChanged == null)
        {
            return;
        }
        
        var changes = DetectChanges(oldConfig, newConfig);
        if (changes.Count > 0)
        {
            var args = new ConfigChangeEventArgs<TConfig>(oldConfig, newConfig, changes);
            ConfigChanged?.Invoke(this, args);
        }
    }
    
    private Dictionary<string, ConfigPropertyChange> DetectChanges(TConfig oldConfig, TConfig newConfig)
    {
        var changes = new Dictionary<string, ConfigPropertyChange>();
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            object oldValue = property.GetValue(oldConfig);
            object newValue = property.GetValue(newConfig);
            
            if (!Equals(oldValue, newValue))
            {
                changes[property.Name] = new ConfigPropertyChange(property.Name, oldValue, newValue);
            }
        }
        
        return changes;
    }
}
```

### 2.5 配置转换器

实现配置转换器，支持配置格式的转换和迁移：

```csharp
public interface IConfigConverter<TSource, TTarget>
    where TSource : class
    where TTarget : class, new()
{
    TTarget Convert(TSource source);
}

// 版本转换器
public class ConfigVersionConverter<TOldConfig, TNewConfig> : IConfigConverter<TOldConfig, TNewConfig>
    where TOldConfig : class
    where TNewConfig : class, new()
{
    private readonly Func<TOldConfig, TNewConfig> _convertFunc;
    
    public ConfigVersionConverter(Func<TOldConfig, TNewConfig> convertFunc)
    {
        _convertFunc = convertFunc ?? throw new ArgumentNullException(nameof(convertFunc));
    }
    
    public TNewConfig Convert(TOldConfig source)
    {
        return _convertFunc(source);
    }
}

// 格式转换器
public class ConfigFormatConverter<TConfig> where TConfig : class, new()
{
    private readonly IConfigSerializer _sourceSerializer;
    private readonly IConfigSerializer _targetSerializer;
    
    public ConfigFormatConverter(IConfigSerializer sourceSerializer, IConfigSerializer targetSerializer)
    {
        _sourceSerializer = sourceSerializer ?? throw new ArgumentNullException(nameof(sourceSerializer));
        _targetSerializer = targetSerializer ?? throw new ArgumentNullException(nameof(targetSerializer));
    }
    
    public string Convert(string source)
    {
        TConfig config = _sourceSerializer.Deserialize<TConfig>(source);
        return _targetSerializer.Serialize(config);
    }
}
```

## 3. 扩展配置管理器

### 3.1 扩展配置管理器

实现扩展配置管理器，支持多种扩展点：

```csharp
public class ExtendedConfigManager<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _provider;
    private readonly IConfigSerializer _serializer;
    private readonly IConfigValidator<TConfig> _validator;
    private readonly IConfigChangeNotifier<TConfig> _notifier;
    private TConfig _currentConfig;
    
    public ExtendedConfigManager(
        IConfigProvider<TConfig> provider,
        IConfigSerializer serializer = null,
        IConfigValidator<TConfig> validator = null,
        IConfigChangeNotifier<TConfig> notifier = null)
    {
        _provider = provider ?? throw new ArgumentNullException(nameof(provider));
        _serializer = serializer ?? new JsonConfigSerializer();
        _validator = validator;
        _notifier = notifier;
    }
    
    public TConfig GetConfig(bool forceReload = false)
    {
        if (_currentConfig == null || forceReload)
        {
            TConfig newConfig = _provider.GetConfig();
            TConfig oldConfig = _currentConfig;
            _currentConfig = newConfig;
            
            if (_notifier != null && oldConfig != null)
            {
                _notifier.NotifyConfigChanged(oldConfig, newConfig);
            }
        }
        
        return _currentConfig;
    }
    
    public void SaveConfig(TConfig config)
    {
        if (_validator != null)
        {
            ValidationResult result = _validator.Validate(config);
            if (!result.IsValid)
            {
                throw new ValidationException("Config validation failed.", result);
            }
        }
        
        TConfig oldConfig = _currentConfig;
        _provider.SaveConfig(config);
        _currentConfig = config;
        
        if (_notifier != null && oldConfig != null)
        {
            _notifier.NotifyConfigChanged(oldConfig, config);
        }
    }
    
    public void SubscribeToChanges(EventHandler<ConfigChangeEventArgs<TConfig>> handler)
    {
        if (_notifier != null && handler != null)
        {
            _notifier.ConfigChanged += handler;
        }
    }
    
    public void UnsubscribeFromChanges(EventHandler<ConfigChangeEventArgs<TConfig>> handler)
    {
        if (_notifier != null && handler != null)
        {
            _notifier.ConfigChanged -= handler;
        }
    }
}

public class ValidationException : Exception
{
    public ValidationResult ValidationResult { get; }
    
    public ValidationException(string message, ValidationResult validationResult)
        : base(message)
    {
        ValidationResult = validationResult;
    }
}
```

### 3.2 配置工厂

实现配置工厂，创建和管理配置实例：

```csharp
public class ConfigFactory
{
    private readonly Dictionary<Type, object> _configManagers = new Dictionary<Type, object>();
    private readonly object _lock = new object();
    
    public ExtendedConfigManager<TConfig> GetConfigManager<TConfig>(bool createIfNotExists = true) where TConfig : class, new()
    {
        Type configType = typeof(TConfig);
        
        lock (_lock)
        {
            if (_configManagers.TryGetValue(configType, out object manager))
            {
                return (ExtendedConfigManager<TConfig>)manager;
            }
            
            if (!createIfNotExists)
            {
                return null;
            }
            
            var newManager = CreateConfigManager<TConfig>();
            _configManagers[configType] = newManager;
            return newManager;
        }
    }
    
    private ExtendedConfigManager<TConfig> CreateConfigManager<TConfig>() where TConfig : class, new()
    {
        // 创建默认的配置管理器
        string configFilePath = GetConfigFilePath<TConfig>();
        var provider = new FileConfigProvider<TConfig>(configFilePath, new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
        
        var validator = new AttributeConfigValidator<TConfig>();
        var notifier = new ConfigChangeNotifier<TConfig>();
        
        return new ExtendedConfigManager<TConfig>(provider, null, validator, notifier);
    }
    
    private string GetConfigFilePath<TConfig>() where TConfig : class, new()
    {
        string baseDir = AppDomain.CurrentDomain.BaseDirectory;
        string configDir = Path.Combine(baseDir, "Config");
        string configFileName = $"{typeof(TConfig).Name}.config";
        return Path.Combine(configDir, configFileName);
    }
}
```

### 3.3 多环境配置

实现多环境配置，支持不同环境的配置：

```csharp
public class EnvironmentAwareConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly Dictionary<string, IConfigProvider<TConfig>> _providers;
    private readonly string _environment;
    
    public EnvironmentAwareConfigProvider(Dictionary<string, IConfigProvider<TConfig>> providers, string environment)
    {
        _providers = providers ?? throw new ArgumentNullException(nameof(providers));
        _environment = environment ?? "Development";
    }
    
    public TConfig GetConfig()
    {
        if (_providers.TryGetValue(_environment, out IConfigProvider<TConfig> provider))
        {
            return provider.GetConfig();
        }
        
        if (_providers.TryGetValue("Default", out provider))
        {
            return provider.GetConfig();
        }
        
        return new TConfig();
    }
    
    public void SaveConfig(TConfig config)
    {
        if (_providers.TryGetValue(_environment, out IConfigProvider<TConfig> provider))
        {
            provider.SaveConfig(config);
        }
        else if (_providers.TryGetValue("Default", out provider))
        {
            provider.SaveConfig(config);
        }
        else
        {
            throw new InvalidOperationException($"No config provider found for environment '{_environment}'.");
        }
    }
}
```

### 3.4 分层配置

实现分层配置，支持配置的层次结构：

```csharp
public class LayeredConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly List<IConfigProvider<TConfig>> _providers;
    
    public LayeredConfigProvider(List<IConfigProvider<TConfig>> providers)
    {
        _providers = providers ?? throw new ArgumentNullException(nameof(providers));
    }
    
    public TConfig GetConfig()
    {
        TConfig result = new TConfig();
        
        // 从底层到顶层应用配置
        foreach (var provider in _providers)
        {
            TConfig layerConfig = provider.GetConfig();
            MergeConfig(result, layerConfig);
        }
        
        return result;
    }
    
    public void SaveConfig(TConfig config)
    {
        // 只保存到最顶层的提供程序
        if (_providers.Count > 0)
        {
            _providers[_providers.Count - 1].SaveConfig(config);
        }
    }
    
    private void MergeConfig(TConfig target, TConfig source)
    {
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            object sourceValue = property.GetValue(source);
            if (sourceValue != null)
            {
                property.SetValue(target, sourceValue);
            }
        }
    }
}
```

## 4. 高级扩展示例

### 4.1 配置热重载

实现配置热重载，自动检测配置文件变化并重新加载：

```csharp
public class HotReloadConfigProvider<TConfig> : IConfigProvider<TConfig>, IDisposable where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly FileSystemWatcher _watcher;
    private readonly string _filePath;
    private readonly object _lock = new object();
    private TConfig _cachedConfig;
    private bool _isReloading;
    
    public event EventHandler<ConfigChangeEventArgs<TConfig>> ConfigChanged;
    
    public HotReloadConfigProvider(string filePath, JsonSerializerOptions options)
    {
        _filePath = filePath;
        _baseProvider = new FileConfigProvider<TConfig>(filePath, options);
        
        string directory = Path.GetDirectoryName(filePath);
        string fileName = Path.GetFileName(filePath);
        
        _watcher = new FileSystemWatcher(directory, fileName)
        {
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime,
            EnableRaisingEvents = true
        };
        
        _watcher.Changed += OnFileChanged;
        _watcher.Created += OnFileChanged;
    }
    
    public TConfig GetConfig()
    {
        lock (_lock)
        {
            if (_cachedConfig == null)
            {
                _cachedConfig = _baseProvider.GetConfig();
            }
            
            return _cachedConfig;
        }
    }
    
    public void SaveConfig(TConfig config)
    {
        lock (_lock)
        {
            TConfig oldConfig = _cachedConfig;
            _baseProvider.SaveConfig(config);
            _cachedConfig = config;
            
            if (oldConfig != null)
            {
                NotifyConfigChanged(oldConfig, config);
            }
        }
    }
    
    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        if (_isReloading)
        {
            return;
        }
        
        _isReloading = true;
        
        try
        {
            // 等待文件写入完成
            Thread.Sleep(100);
            
            lock (_lock)
            {
                TConfig oldConfig = _cachedConfig;
                _cachedConfig = _baseProvider.GetConfig();
                
                if (oldConfig != null)
                {
                    NotifyConfigChanged(oldConfig, _cachedConfig);
                }
            }
        }
        finally
        {
            _isReloading = false;
        }
    }
    
    private void NotifyConfigChanged(TConfig oldConfig, TConfig newConfig)
    {
        if (ConfigChanged == null)
        {
            return;
        }
        
        var notifier = new ConfigChangeNotifier<TConfig>();
        notifier.NotifyConfigChanged(oldConfig, newConfig);
    }
    
    public void Dispose()
    {
        _watcher?.Dispose();
    }
}
```

### 4.2 配置加密

实现配置加密，保护敏感配置信息：

```csharp
public class EncryptedConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly IEncryptionService _encryptionService;
    
    public EncryptedConfigProvider(IConfigProvider<TConfig> baseProvider, IEncryptionService encryptionService)
    {
        _baseProvider = baseProvider ?? throw new ArgumentNullException(nameof(baseProvider));
        _encryptionService = encryptionService ?? throw new ArgumentNullException(nameof(encryptionService));
    }
    
    public TConfig GetConfig()
    {
        TConfig config = _baseProvider.GetConfig();
        DecryptProperties(config);
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        // 创建配置的副本，以避免修改原始配置
        TConfig configCopy = JsonSerializer.Deserialize<TConfig>(JsonSerializer.Serialize(config));
        
        // 加密属性
        EncryptProperties(configCopy);
        
        // 保存加密后的配置
        _baseProvider.SaveConfig(configCopy);
    }
    
    private void EncryptProperties(TConfig config)
    {
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string plainValue = (string)property.GetValue(config);
                if (!string.IsNullOrEmpty(plainValue))
                {
                    string encryptedValue = _encryptionService.Encrypt(plainValue, encryptedAttr.KeyName);
                    property.SetValue(config, encryptedValue);
                }
            }
        }
    }
    
    private void DecryptProperties(TConfig config)
    {
        Type configType = typeof(TConfig);
        PropertyInfo[] properties = configType.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            EncryptedAttribute encryptedAttr = property.GetCustomAttribute<EncryptedAttribute>();
            if (encryptedAttr != null && property.PropertyType == typeof(string))
            {
                string encryptedValue = (string)property.GetValue(config);
                if (!string.IsNullOrEmpty(encryptedValue))
                {
                    string decryptedValue = _encryptionService.Decrypt(encryptedValue, encryptedAttr.KeyName);
                    property.SetValue(config, decryptedValue);
                }
            }
        }
    }
}

public interface IEncryptionService
{
    string Encrypt(string plainText, string keyName);
    string Decrypt(string cipherText, string keyName);
}
```

### 4.3 配置依赖注入

实现配置依赖注入，支持在依赖注入容器中使用配置：

```csharp
// 使用 Microsoft.Extensions.DependencyInjection
public static class ConfigServiceCollectionExtensions
{
    public static IServiceCollection AddConfig<TConfig>(this IServiceCollection services, Action<ConfigOptions<TConfig>> configureOptions = null)
        where TConfig : class, new()
    {
        var options = new ConfigOptions<TConfig>();
        configureOptions?.Invoke(options);
        
        // 注册配置提供程序
        services.AddSingleton<IConfigProvider<TConfig>>(serviceProvider =>
        {
            return options.ProviderFactory(serviceProvider);
        });
        
        // 注册配置管理器
        services.AddSingleton<ExtendedConfigManager<TConfig>>(serviceProvider =>
        {
            var provider = serviceProvider.GetRequiredService<IConfigProvider<TConfig>>();
            var validator = options.ValidatorFactory?.Invoke(serviceProvider);
            var notifier = options.NotifierFactory?.Invoke(serviceProvider);
            
            return new ExtendedConfigManager<TConfig>(provider, null, validator, notifier);
        });
        
        // 注册配置实例
        services.AddSingleton<TConfig>(serviceProvider =>
        {
            var manager = serviceProvider.GetRequiredService<ExtendedConfigManager<TConfig>>();
            return manager.GetConfig();
        });
        
        return services;
    }
}

public class ConfigOptions<TConfig> where TConfig : class, new()
{
    public Func<IServiceProvider, IConfigProvider<TConfig>> ProviderFactory { get; set; }
    public Func<IServiceProvider, IConfigValidator<TConfig>> ValidatorFactory { get; set; }
    public Func<IServiceProvider, IConfigChangeNotifier<TConfig>> NotifierFactory { get; set; }
    
    public ConfigOptions()
    {
        // 默认使用文件配置提供程序
        ProviderFactory = serviceProvider =>
        {
            string baseDir = AppDomain.CurrentDomain.BaseDirectory;
            string configDir = Path.Combine(baseDir, "Config");
            string configFileName = $"{typeof(TConfig).Name}.config";
            string configFilePath = Path.Combine(configDir, configFileName);
            
            return new FileConfigProvider<TConfig>(configFilePath, new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });
        };
    }
}
```

### 4.4 配置监控

实现配置监控，监控配置的使用情况：

```csharp
public class MonitoredConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly IConfigMonitor _monitor;
    
    public MonitoredConfigProvider(IConfigProvider<TConfig> baseProvider, IConfigMonitor monitor)
    {
        _baseProvider = baseProvider ?? throw new ArgumentNullException(nameof(baseProvider));
        _monitor = monitor ?? throw new ArgumentNullException(nameof(monitor));
    }
    
    public TConfig GetConfig()
    {
        var stopwatch = Stopwatch.StartNew();
        TConfig config = _baseProvider.GetConfig();
        stopwatch.Stop();
        
        _monitor.RecordOperation("GetConfig", typeof(TConfig).Name, stopwatch.ElapsedMilliseconds);
        
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        var stopwatch = Stopwatch.StartNew();
        _baseProvider.SaveConfig(config);
        stopwatch.Stop();
        
        _monitor.RecordOperation("SaveConfig", typeof(TConfig).Name, stopwatch.ElapsedMilliseconds);
    }
}

public interface IConfigMonitor
{
    void RecordOperation(string operation, string configType, long elapsedMilliseconds);
    Dictionary<string, ConfigOperationStats> GetStats();
}

public class ConfigOperationStats
{
    public string Operation { get; set; }
    public string ConfigType { get; set; }
    public int Count { get; set; }
    public long TotalElapsedMilliseconds { get; set; }
    public long MinElapsedMilliseconds { get; set; }
    public long MaxElapsedMilliseconds { get; set; }
    public double AverageElapsedMilliseconds => Count > 0 ? (double)TotalElapsedMilliseconds / Count : 0;
}

public class ConfigMonitor : IConfigMonitor
{
    private readonly Dictionary<string, ConfigOperationStats> _stats = new Dictionary<string, ConfigOperationStats>();
    private readonly object _lock = new object();
    
    public void RecordOperation(string operation, string configType, long elapsedMilliseconds)
    {
        string key = $"{operation}_{configType}";
        
        lock (_lock)
        {
            if (!_stats.TryGetValue(key, out ConfigOperationStats stats))
            {
                stats = new ConfigOperationStats
                {
                    Operation = operation,
                    ConfigType = configType,
                    Count = 0,
                    TotalElapsedMilliseconds = 0,
                    MinElapsedMilliseconds = long.MaxValue,
                    MaxElapsedMilliseconds = 0
                };
                
                _stats[key] = stats;
            }
            
            stats.Count++;
            stats.TotalElapsedMilliseconds += elapsedMilliseconds;
            stats.MinElapsedMilliseconds = Math.Min(stats.MinElapsedMilliseconds, elapsedMilliseconds);
            stats.MaxElapsedMilliseconds = Math.Max(stats.MaxElapsedMilliseconds, elapsedMilliseconds);
        }
    }
    
    public Dictionary<string, ConfigOperationStats> GetStats()
    {
        lock (_lock)
        {
            return new Dictionary<string, ConfigOperationStats>(_stats);
        }
    }
}
```

## 5. 扩展最佳实践

### 5.1 扩展设计原则

- **单一职责原则**：每个扩展应该只负责一个功能
- **开闭原则**：扩展应该对修改关闭，对扩展开放
- **接口隔离原则**：使用小而专注的接口，而不是大而全的接口
- **依赖倒置原则**：依赖抽象，而不是具体实现
- **组合优于继承**：使用组合而不是继承来扩展功能

### 5.2 扩展实现指南

1. **定义清晰的接口**：为每个扩展点定义清晰的接口
2. **提供默认实现**：为每个接口提供默认实现
3. **使用工厂模式**：使用工厂模式创建扩展实例
4. **支持依赖注入**：设计扩展以支持依赖注入
5. **提供扩展点文档**：为每个扩展点提供详细的文档
6. **编写单元测试**：为每个扩展编写单元测试
7. **保持向后兼容性**：确保扩展不会破坏现有功能

### 5.3 扩展示例

```csharp
// 示例：创建一个使用多个扩展的配置系统
public class ExtendedConfigExample
{
    public static void Run()
    {
        // 创建配置工厂
        var configFactory = new ConfigFactory();
        
        // 获取配置管理器
        var configManager = configFactory.GetConfigManager<AppConfig>();
        
        // 获取配置
        var config = configManager.GetConfig();
        
        // 修改配置
        config.ApplicationName = "MyApp";
        config.Version = "1.0.0";
        config.DatabaseConnection = "Server=localhost;Database=mydb;User=user;Password=password";
        
        // 保存配置
        try
        {
            configManager.SaveConfig(config);
            Console.WriteLine("Config saved successfully.");
        }
        catch (ValidationException ex)
        {
            Console.WriteLine("Config validation failed:");
            foreach (var error in ex.ValidationResult.Errors)
            {
                Console.WriteLine($"Property: {error.Key}");
                foreach (var message in error.Value)
                {
                    Console.WriteLine($"  - {message}");
                }
            }
        }
        
        // 订阅配置变更
        configManager.SubscribeToChanges((sender, e) =>
        {
            Console.WriteLine("Config changed:");
            foreach (var change in e.Changes)
            {
                Console.WriteLine($"Property: {change.Key}, Old: {change.Value.OldValue}, New: {change.Value.NewValue}");
            }
        });
    }
}

// 示例配置类
public class AppConfig
{
    [Required]
    public string ApplicationName { get; set; } = "DefaultApp";
    
    [Required]
    public string Version { get; set; } = "0.0.0";
    
    [Required]
    [Encrypted]
    public string DatabaseConnection { get; set; } = "";
    
    public bool DebugMode { get; set; } = false;
    
    [Range(1, 3600)]
    public int TimeoutSeconds { get; set; } = 30;
}
```

## 6. 常见问题和解决方案

### 6.1 如何扩展配置系统以支持新的序列化格式？

**问题**：如何扩展配置系统以支持新的序列化格式，如 YAML 或 TOML？

**解决方案**：
1. 实现 `IConfigSerializer` 接口，提供新格式的序列化和反序列化功能
2. 创建使用新序列化器的配置提供程序
3. 使用扩展配置管理器，传入新的序列化器

```csharp
// 示例：支持 YAML 格式
var yamlSerializer = new YamlConfigSerializer();
var yamlProvider = new FileConfigProvider<AppConfig>("config.yaml", null);
var configManager = new ExtendedConfigManager<AppConfig>(yamlProvider, yamlSerializer);
```

### 6.2 如何实现配置的版本控制和迁移？

**问题**：如何处理配置格式的变化和版本升级？

**解决方案**：
1. 为每个配置版本定义单独的类
2. 实现版本转换器，将旧版本配置转换为新版本
3. 在加载配置时检测版本并执行迁移

```csharp
// 示例：配置版本迁移
public class ConfigMigrationProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly Dictionary<string, object> _migrators;
    
    public ConfigMigrationProvider(IConfigProvider<TConfig> baseProvider, Dictionary<string, object> migrators)
    {
        _baseProvider = baseProvider;
        _migrators = migrators;
    }
    
    public TConfig GetConfig()
    {
        // 获取配置并检查版本
        var config = _baseProvider.GetConfig();
        
        // 执行迁移（简化示例）
        // 实际实现应该检测版本并执行相应的迁移
        
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        _baseProvider.SaveConfig(config);
    }
}
```

### 6.3 如何处理配置依赖关系？

**问题**：如何处理配置之间的依赖关系？

**解决方案**：
1. 定义配置依赖关系
2. 使用配置工厂管理依赖关系
3. 在加载配置时解析依赖

```csharp
// 示例：配置依赖关系
public class DependentConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly Dictionary<Type, object> _dependencies;
    
    public DependentConfigProvider(IConfigProvider<TConfig> baseProvider, Dictionary<Type, object> dependencies)
    {
        _baseProvider = baseProvider;
        _dependencies = dependencies;
    }
    
    public TConfig GetConfig()
    {
        var config = _baseProvider.GetConfig();
        
        // 解析依赖（简化示例）
        // 实际实现应该注入依赖到配置中
        
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        _baseProvider.SaveConfig(config);
    }
}
```

### 6.4 如何实现配置的缓存和性能优化？

**问题**：如何优化配置的加载和访问性能？

**解决方案**：
1. 实现缓存配置提供程序
2. 使用延迟加载
3. 实现配置监控，识别性能瓶颈

```csharp
// 示例：缓存配置提供程序
public class CachedConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private TConfig _cachedConfig;
    private readonly object _lock = new object();
    
    public CachedConfigProvider(IConfigProvider<TConfig> baseProvider)
    {
        _baseProvider = baseProvider;
    }
    
    public TConfig GetConfig()
    {
        lock (_lock)
        {
            if (_cachedConfig == null)
            {
                _cachedConfig = _baseProvider.GetConfig();
            }
            
            return _cachedConfig;
        }
    }
    
    public void SaveConfig(TConfig config)
    {
        lock (_lock)
        {
            _baseProvider.SaveConfig(config);
            _cachedConfig = config;
        }
    }
}
```

### 6.5 如何实现配置的安全性？

**问题**：如何保护敏感配置信息？

**解决方案**：
1. 实现加密配置提供程序
2. 使用安全存储提供程序
3. 实现访问控制

```csharp
// 示例：安全配置提供程序
public class SecureConfigProvider<TConfig> : IConfigProvider<TConfig> where TConfig : class, new()
{
    private readonly IConfigProvider<TConfig> _baseProvider;
    private readonly IEncryptionService _encryptionService;
    
    public SecureConfigProvider(IConfigProvider<TConfig> baseProvider, IEncryptionService encryptionService)
    {
        _baseProvider = baseProvider;
        _encryptionService = encryptionService;
    }
    
    public TConfig GetConfig()
    {
        var config = _baseProvider.GetConfig();
        
        // 解密敏感属性
        // ...
        
        return config;
    }
    
    public void SaveConfig(TConfig config)
    {
        // 创建配置的副本
        var configCopy = JsonSerializer.Deserialize<TConfig>(JsonSerializer.Serialize(config));
        
        // 加密敏感属性
        // ...
        
        _baseProvider.SaveConfig(configCopy);
    }
}
```

## 7. 总结

本文档提供了 Pek.Common 配置系统的扩展性指南和最佳实践。通过实现各种扩展点，如配置提供程序、序列化器、验证器、变更通知和转换器，可以扩展配置系统以满足不同的需求。

扩展配置系统时，应该遵循扩展设计原则，如单一职责原则、开闭原则、接口隔离原则、依赖倒置原则和组合优于继承原则。通过定义清晰的接口、提供默认实现、使用工厂模式、支持依赖注入、提供扩展点文档、编写单元测试和保持向后兼容性，可以创建高质量的扩展。

通过遵循本文档中的指南和最佳实践，可以创建灵活、可扩展的配置系统，满足各种应用场景的需求。