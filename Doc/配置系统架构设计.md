# Pek.Common 配置系统架构设计

## 1. 系统概述

Pek.Common 配置系统是一个轻量级、类型安全的配置管理框架，旨在提供简单易用的配置访问、保存和重新加载功能。该系统采用基于 JSON 的序列化机制，支持 AOT (Ahead-of-Time) 编译环境，并提供了良好的扩展性。

### 1.1 设计目标

- **类型安全**：提供强类型的配置访问方式，避免运行时类型错误
- **易用性**：简化配置的创建、访问和修改过程
- **可扩展性**：支持自定义配置类型和序列化选项
- **性能优化**：通过缓存和延迟加载提高性能
- **AOT 兼容**：支持在 AOT 编译环境中正常工作
- **线程安全**：确保在多线程环境中安全访问配置

## 2. 系统架构

配置系统由以下核心组件组成：

1. **Config 基类**：所有配置类的基类，提供基本的保存功能
2. **Config<TConfig> 泛型基类**：提供类型安全的配置访问和重新加载功能
3. **ConfigManager**：管理配置的注册、加载和保存
4. **自定义配置类**：用户定义的特定配置类，如 Settings

### 2.1 架构图

```
+-------------------+      +-------------------------+
|                   |      |                         |
|  ConfigManager    |<---->|  Config<TConfig>        |
|  (静态类)         |      |  (泛型基类)             |
|                   |      |                         |
+-------------------+      +-------------------------+
         ^                            ^
         |                            |
         |                            |
         v                            |
+-------------------+                 |
|                   |                 |
|  Config           |                 |
|  (基类)           |                 |
|                   |                 |
+-------------------+                 |
         ^                            |
         |                            |
         |                            |
         |                            |
+-------------------+                 |
|                   |                 |
|  Settings         |-----------------+
|  (具体配置类)     |
|                   |
+-------------------+
```

## 3. 组件详解

### 3.1 Config 基类

`Config` 是所有配置类的基类，提供基本的保存功能。

**主要职责**：
- 提供配置保存的基本接口

**关键方法**：
- `Save()`：保存配置到文件

### 3.2 Config<TConfig> 泛型基类

`Config<TConfig>` 是一个泛型基类，继承自 `Config`，提供类型安全的配置访问和重新加载功能。

**主要职责**：
- 提供类型安全的配置访问
- 管理配置实例的生命周期
- 提供配置重新加载功能

**关键属性和方法**：
- `Current`：获取当前配置实例（单例模式）
- `Reload()`：重新加载配置
- `Save()`：保存配置（重写基类方法）

**实现细节**：
- 使用双重检查锁定确保线程安全
- 延迟加载配置实例
- 通过 `ConfigManager` 加载和保存配置

### 3.3 ConfigManager

`ConfigManager` 是一个静态类，负责管理配置的注册、加载和保存。

**主要职责**：
- 注册配置类型及其序列化选项
- 加载配置文件
- 保存配置到文件
- 管理配置文件路径

**关键方法**：
- `RegisterConfig<TConfig>(JsonSerializerOptions options, string? fileName = null)`：注册配置类型
- `GetConfig<TConfig>(bool forceReload = false)`：获取配置实例
- `SaveConfig<TConfig>(TConfig config)`：保存配置到文件
- `LoadConfig<TConfig>()`：从文件加载配置
- `GetConfigFilePath<TConfig>()`：获取配置文件路径

**实现细节**：
- 使用字典存储配置类型与序列化选项的映射
- 使用 System.Text.Json 进行序列化和反序列化
- 自动创建配置目录
- 处理文件不存在和格式错误的情况

### 3.4 自定义配置类（如 Settings）

自定义配置类是用户定义的特定配置类，继承自 `Config<TConfig>`。

**主要职责**：
- 定义特定的配置属性
- 提供默认值
- 注册配置类型

**实现细节**：
- 在静态构造函数中注册配置类型
- 为 AOT 兼容性创建 JsonSerializerContext
- 定义配置属性及其默认值

## 4. 工作流程

### 4.1 配置注册流程

1. 自定义配置类在静态构造函数中调用 `ConfigManager.RegisterConfig<TConfig>()`
2. `ConfigManager` 将配置类型和序列化选项存储在内部字典中

### 4.2 配置访问流程

1. 客户端代码通过 `TConfig.Current` 访问配置实例
2. `Config<TConfig>` 检查是否已有缓存的实例
3. 如果没有，调用 `ConfigManager.GetConfig<TConfig>()` 获取实例
4. `ConfigManager` 尝试从文件加载配置，如果文件不存在或格式错误，则创建新实例
5. 返回配置实例

### 4.3 配置保存流程

1. 客户端代码修改配置属性后调用 `config.Save()`
2. `Config<TConfig>` 的 `Save()` 方法调用 `ConfigManager.SaveConfig<TConfig>(this)`
3. `ConfigManager` 使用注册的序列化选项将配置序列化为 JSON
4. 将 JSON 写入配置文件

### 4.4 配置重新加载流程

1. 客户端代码调用 `TConfig.Reload()`
2. `Config<TConfig>` 清除缓存的实例
3. 调用 `ConfigManager.GetConfig<TConfig>(true)` 强制重新加载
4. `ConfigManager` 从文件重新加载配置
5. 返回新的配置实例

## 5. AOT 兼容性设计

### 5.1 挑战

AOT (Ahead-of-Time) 编译环境对反射和动态代码生成有限制，这会影响 JSON 序列化和反序列化。

### 5.2 解决方案

配置系统通过以下方式确保 AOT 兼容性：

1. **源代码生成**：使用 System.Text.Json 的源代码生成功能
2. **JsonSerializerContext**：为每个配置类创建 JsonSerializerContext 派生类
3. **预初始化**：在程序启动时预初始化配置类

### 5.3 实现细节

1. 为配置类创建 JsonSerializerContext 派生类：

```csharp
[JsonSerializable(typeof(Settings))]
public partial class SettingsJsonContext : JsonSerializerContext
{
}
```

2. 在配置类的静态构造函数中使用 JsonSerializerContext：

```csharp
static Settings()
{
    var options = new JsonSerializerOptions
    {
        TypeInfoResolver = SettingsJsonContext.Default,
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    
    ConfigManager.RegisterConfig<Settings>(options);
}
```

3. 在程序启动时预初始化配置类：

```csharp
private static void InitializeConfigs()
{
    try
    {
        // 手动注册配置
        var jsonOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = SettingsJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<Settings>(jsonOptions);
        
        // 触发初始化
        var settings = Settings.Current;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"配置初始化失败: {ex.Message}");
    }
}
```

## 6. 线程安全设计

### 6.1 挑战

在多线程环境中，配置的访问和修改可能导致竞态条件和数据不一致。

### 6.2 解决方案

配置系统通过以下方式确保线程安全：

1. **双重检查锁定**：在 `Config<TConfig>` 中使用双重检查锁定模式
2. **线程安全的字典**：在 `ConfigManager` 中使用线程安全的集合
3. **原子操作**：确保配置实例的创建和替换是原子操作

### 6.3 实现细节

```csharp
public static TConfig Current
{
    get
    {
        if (_current == null)
        {
            lock (_lock)
            {
                if (_current == null)
                {
                    _current = ConfigManager.GetConfig<TConfig>();
                }
            }
        }
        return _current;
    }
}
```

## 7. 扩展点

配置系统提供了以下扩展点：

### 7.1 自定义序列化选项

通过 `RegisterConfig<TConfig>(JsonSerializerOptions options)` 方法，可以为每个配置类型提供自定义的序列化选项。

### 7.2 自定义配置文件名

通过 `RegisterConfig<TConfig>(JsonSerializerOptions options, string? fileName)` 方法，可以为配置类型指定自定义的文件名。

### 7.3 重写 Save 方法

通过重写 `Save()` 方法，可以在保存配置前添加自定义逻辑，如验证。

```csharp
public override void Save()
{
    // 自定义逻辑
    ValidateConfig();
    
    // 调用基类方法
    base.Save();
}
```

## 8. 性能优化

配置系统采用了以下性能优化措施：

### 8.1 延迟加载

配置实例仅在首次访问时才会被加载，避免不必要的 I/O 操作。

### 8.2 缓存机制

配置实例在加载后会被缓存，避免重复读取文件。

### 8.3 高效序列化

使用 System.Text.Json 的源代码生成功能，避免反射带来的性能开销。

## 9. 限制和约束

### 9.1 已知限制

- 不支持配置加密
- 不支持配置验证
- 不支持配置变更通知
- 不支持多环境配置
- 不支持配置分组和层次结构

### 9.2 设计约束

- 配置类必须继承自 `Config<TConfig>`
- 配置类必须有无参构造函数
- 配置属性必须是可序列化的
- 在 AOT 环境中，必须为配置类创建 JsonSerializerContext

## 10. 未来扩展

### 10.1 潜在改进

- **配置验证**：添加配置验证机制
- **配置加密**：支持敏感配置的加密
- **配置变更通知**：实现观察者模式，通知配置变更
- **配置版本控制**：支持配置版本迁移
- **配置热重载**：支持配置文件变更时自动重新加载
- **配置分组和层次结构**：支持配置的分组和层次结构
- **多环境配置**：支持不同环境的配置
- **依赖注入集成**：与依赖注入框架集成

### 10.2 架构演进

- **配置提供程序抽象**：引入配置提供程序接口，支持多种配置源
- **配置转换器**：支持配置值的自定义转换
- **配置中间件**：引入中间件模式，支持配置处理管道

## 11. 总结

Pek.Common 配置系统是一个轻量级、类型安全的配置管理框架，提供了简单易用的配置访问、保存和重新加载功能。通过精心的设计，该系统在保持简单性的同时，确保了线程安全和 AOT 兼容性，并提供了良好的扩展性。

虽然当前版本有一些限制，但通过未来的扩展，可以进一步增强系统的功能和灵活性，满足更复杂的配置管理需求。