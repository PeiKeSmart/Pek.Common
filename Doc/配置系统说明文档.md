# Pek.Common 配置系统说明文档

## 1. 概述

配置系统是 Pek.Common 库的核心功能之一，提供了一种简单、高效且类型安全的方式来管理应用程序配置。该系统支持配置的读取、保存、重新加载等操作，并且完全兼容 AOT (Ahead-of-Time) 编译环境。

### 主要特点

- **类型安全**：使用泛型和强类型配置类
- **自动序列化/反序列化**：基于 System.Text.Json
- **配置文件自动管理**：自动创建配置目录和文件
- **AOT 兼容**：支持在 AOT 编译环境中使用
- **高性能**：使用缓存机制提高访问性能
- **线程安全**：支持多线程环境下的配置访问

## 2. 系统架构

配置系统由以下几个主要组件组成：

1. **Config 基类**：所有配置类的基类，提供基本的保存功能
2. **Config<TConfig> 泛型基类**：提供类型安全的配置访问和重新加载功能
3. **ConfigManager**：管理配置的注册、加载和保存
4. **Settings**：示例配置类，展示了如何创建和使用配置

### 类图

```
+-------------------+     +------------------------+     +-------------------+
|      Config       |<---- |     Config<TConfig>    |<---- |     Settings     |
+-------------------+     +------------------------+     +-------------------+
| + Save()          |     | + Current (static)     |     | + Name           |
+-------------------+     | + Reload() (static)    |     | + Version        |
         ^                +------------------------+     | + Debug          |
         |                                              | + TimeoutSeconds |
         |                                              +-------------------+
         |                +------------------------+
         +----------------|    ConfigManager      |
                          +------------------------+
                          | + RegisterConfig<T>() |
                          | + GetConfig<T>()      |
                          | + SaveConfig()        |
                          +------------------------+
```

## 3. 使用方法

### 3.1 创建配置类

要创建自定义配置类，需要继承 `Config<TConfig>` 并实现必要的属性：

```csharp
[JsonSerializable(typeof(MyConfig))]
public partial class MyConfigJsonContext : JsonSerializerContext
{
}

public class MyConfig : Config<MyConfig>
{
    // 配置属性
    public string? ApplicationName { get; set; } = "默认应用";
    public int MaxConnections { get; set; } = 100;
    
    // 静态构造函数，注册配置
    static MyConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = MyConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        ConfigManager.RegisterConfig<MyConfig>(options, "MyConfig");
    }
}
```

### 3.2 访问配置

访问配置非常简单，只需使用配置类的 `Current` 静态属性：

```csharp
// 获取当前配置
var config = MyConfig.Current;

// 读取配置值
string appName = config.ApplicationName;
int maxConn = config.MaxConnections;

// 修改配置
config.ApplicationName = "新应用名称";
config.MaxConnections = 200;

// 保存配置
config.Save();

// 重新加载配置
MyConfig.Reload();
```

### 3.3 AOT 兼容性配置

在 AOT 环境中使用配置系统需要特别注意以下几点：

1. 为每个配置类创建对应的 `JsonSerializerContext` 派生类
2. 使用 `[JsonSerializable]` 特性标记所有需要序列化的类型
3. 在注册配置时提供正确的 `JsonSerializerOptions`，并设置 `TypeInfoResolver`

示例：

```csharp
// 在程序启动时确保配置类已初始化
public static void InitializeConfigs()
{
    try
    {
        // 预先初始化配置类，确保其静态构造函数被调用
        var jsonOptions = new JsonSerializerOptions
        {
            TypeInfoResolver = MyConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        
        // 手动注册配置
        ConfigManager.RegisterConfig<MyConfig>(jsonOptions, "MyConfig");
        
        // 访问配置触发初始化
        var config = MyConfig.Current;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"配置初始化失败: {ex.Message}");
    }
}
```

## 4. 配置文件管理

### 4.1 配置文件位置

配置文件默认保存在应用程序根目录下的 `Config` 文件夹中：

```
应用程序根目录/Config/配置类名.config
```

例如，`Settings` 配置类的配置文件路径为：

```
应用程序根目录/Config/Settings.config
```

### 4.2 配置文件格式

配置文件使用 JSON 格式存储，例如：

```json
{
  "name": "测试应用",
  "version": "2.0.0",
  "debug": true,
  "timeoutSeconds": 60
}
```

## 5. 性能优化

配置系统使用了以下几种性能优化技术：

1. **缓存机制**：配置实例在首次加载后会被缓存，避免重复读取文件
2. **延迟加载**：配置只在首次访问时才会被加载
3. **线程安全的单例模式**：使用双重检查锁定确保线程安全
4. **AOT 兼容的序列化**：使用 System.Text.Json 的源生成器避免反射

## 6. 最佳实践

### 6.1 配置类设计

- 为每个配置类提供合理的默认值
- 使用可空类型表示可选配置项
- 在静态构造函数中注册配置
- 为每个配置类创建对应的 JsonSerializerContext

### 6.2 配置访问

- 尽量在应用程序启动时预初始化所有配置类
- 避免频繁调用 `Save()` 方法，可能影响性能
- 在多线程环境中，注意配置的并发访问和修改

### 6.3 AOT 兼容性

- 确保所有需要序列化的类型都在 JsonSerializerContext 中注册
- 避免在配置类中使用不支持 AOT 的特性（如反射）
- 在程序启动时手动初始化配置类

## 7. 常见问题

### 7.1 配置未正确加载

可能的原因：
- 配置文件不存在或格式错误
- 未正确注册配置类
- 序列化选项配置错误

解决方法：
- 检查配置文件是否存在且格式正确
- 确保在使用配置前已注册配置类
- 验证序列化选项是否正确设置

### 7.2 AOT 环境中的序列化错误

可能的原因：
- 缺少必要的 JsonSerializerContext
- 未在 JsonSerializerContext 中注册所有需要序列化的类型

解决方法：
- 为每个配置类创建对应的 JsonSerializerContext
- 使用 [JsonSerializable] 特性注册所有需要序列化的类型
- 在程序启动时手动初始化配置类

## 8. 示例代码

### 8.1 完整的配置类示例

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MyApp.Configuration;

[JsonSerializable(typeof(AppConfig))]
[JsonSerializable(typeof(string))]
[JsonSerializable(typeof(bool))]
[JsonSerializable(typeof(int))]
public partial class AppConfigJsonContext : JsonSerializerContext
{
}

public class AppConfig : Config<AppConfig>
{
    public string? ApplicationName { get; set; } = "我的应用";
    public string? Version { get; set; } = "1.0.0";
    public bool EnableLogging { get; set; } = true;
    public int CacheTimeoutMinutes { get; set; } = 15;
    
    static AppConfig()
    {
        var options = new JsonSerializerOptions
        {
            TypeInfoResolver = AppConfigJsonContext.Default,
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };
        
        ConfigManager.RegisterConfig<AppConfig>(options, "AppConfig");
    }
}
```

### 8.2 程序启动时初始化配置

```csharp
public static class Program
{
    public static void Main(string[] args)
    {
        // 初始化配置系统
        InitializeConfigs();
        
        // 应用程序逻辑
        var config = AppConfig.Current;
        Console.WriteLine($"应用名称: {config.ApplicationName}");
        Console.WriteLine($"版本: {config.Version}");
    }
    
    private static void InitializeConfigs()
    {
        try
        {
            // 预先初始化AppConfig，确保其静态构造函数被调用
            var jsonOptions = new JsonSerializerOptions
            {
                TypeInfoResolver = AppConfigJsonContext.Default,
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };
            
            // 手动注册配置
            ConfigManager.RegisterConfig<AppConfig>(jsonOptions, "AppConfig");
            
            // 访问配置触发初始化
            var config = AppConfig.Current;
            Console.WriteLine("✅ 配置系统初始化成功");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ 配置系统初始化失败: {ex.Message}");
        }
    }
}
```

## 9. 总结

Pek.Common 配置系统提供了一种简单、高效且类型安全的方式来管理应用程序配置。通过继承 `Config<TConfig>` 基类并实现必要的属性，可以轻松创建自定义配置类。配置系统支持配置的读取、保存、重新加载等操作，并且完全兼容 AOT 编译环境。

配置系统的设计注重性能和易用性，使用缓存机制提高访问性能，使用线程安全的单例模式确保多线程环境下的安全访问。通过遵循本文档中的最佳实践，可以充分发挥配置系统的优势，提高应用程序的可维护性和性能。